<HTML>

<HEAD>
	<meta name=vs_targetSchema content="HTML 4.0">
	<meta name=vs_defaultClientScript content="JavaScript">
	<TITLE>XOGame</TITLE>
	<META NAME="GENERATOR" Content="Microsoft Visual Studio">
	<META HTTP-EQUIV="Content-Type" content="text/html">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="icon" type="image/png" href="xox.png">
</HEAD>

<BODY id="body">
	<script language=javascript>

		let fieldSize = 7;// 7 - 9 - 11
		let FS = fieldSize;
		let gameLevel = 1; // 0 - hight level, 1 - easy, 2 - medium, 3 - hard
		let firstColorIndex = 0, secondColorIndex = 1, fieldMatrix = [], his = [];
		let greenVar = 0, grayCellId;//
		let newLevel = 0;
		let gameColorIndex = -1, roboSwitch = 0, gameOver = 0, changeSize = 0;
		let matrixCell = [];
		let lightGreenColor, darkGreenColor;
		const pref = "v", idTab = "vartab", delayTime = 1500;
		const date = new Date();
		date.setFullYear(date.getFullYear() + 1); // +1 рік від поточної дати
		const expires = date.toUTCString();
		const width = window.innerWidth;
		let linesWidth = 20;
		let tableWidth = 1000;
		let qrcodeWidth = 100;
		let orientation = (window.innerWidth > window.innerHeight) ? "landscape" : "portrait";
		let snake = 0;
		let optymalMatrix = [];
		let blickMatrix = [];
		let colorPalette = 0, darkMode = 0, advanced = 0;

		function cellId(n, x, y) {
			return n + String(y).padStart(2, '0') + String(x).padStart(2, '0');
		}

		function cellIdL(n, x, y) {
			return n + String(y).padStart(4, '0') + String(x).padStart(4, '0');
		}

		function index2Color(index) {
			colorPalette = Number(getValue("colorPalette", 0));
			darkMode = Number(getValue("darkMode", 0));
			switch (index) {
				case 0: return darkMode === 0 ? "#ffffff" : "#000000"; // white / black
				case 1: return darkMode === 0 ? "#000000" : "ffffff"; // black / white
				case -1: return colorPalette === 0 ? "#0000ff" : "#ff0000"; // blue/ red
				case -2: return colorPalette === 0 ? "#ffff00" : "#00ff00"; // yellow/ green
				case 2: return darkMode === 0 ? "#e0e0e0" : "#202020"; // gray
				case 10: return darkMode === 0 ? "#f0fff0" : "#102010"; // light green / dark green
				case 11: return darkMode === 0 ? "#808080" : "#808080"; // darkGreenColor
				default: return darkMode === 0 ? "#ffffff" : "#000000"; // white / black
			}
		}

		function index2ColorLight(index) {
			colorPalette = Number(getValue("colorPalette", 0));
			switch (index) {
				case 0: return "#ffffff"; // white 
				case 1: return "#000000"; // black 
				case -1: return colorPalette === 0 ? "#0000ff" : "#ff0000"; // blue/ red
				case -2: return colorPalette === 0 ? "#ffff00" : "#00ff00"; // yellow/ green
				case 2: return "#e0e0e0"; // gray
				default: return "#ffffff"; // white 
			}
		}

		function delay(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }

		function getCookie(name) {
			const value = `; ${document.cookie}`;
			const parts = value.split(`; ${name}=`);
			if (parts.length === 2) return parts.pop().split(';').shift();
		}

		function printCookie() {
			document.getElementById("displ").innerHTML = document.cookie;
		}

		function deleteCookie() {
			localStorage.clear();
		}

		function resetGame() {
			if (confirm('Are you sure you want to completely reset the game??')) {
				localStorage.clear();
				location.reload();
			}
		}

		//Bill function to count the number of lines
		function bill(fieldSize) {
			let a = 0, b = 0;
			for (let j = 0; j < fieldSize; j++) {
				for (let k = 0; k < fieldSize; k++) {
					const val = fieldMatrix[j * 2 + 1][k * 2 + 1];
					if (!((j * 2 + 1) === 1 && (k * 2 + 1) === 1)) {
						if (val === firstColorIndex) a++;// blue
						if (val === secondColorIndex) b++;// yellow
					}
				}
			}
			displOne(a, b);
			displText(a, b);
			if (a + b < fieldSize * fieldSize - ((fieldSize - 1) / 2) * (((fieldSize - 1) / 2) - 1) * 2) {
				writeMatrix();
			} else {
				localStorage.removeItem('fieldMatrix');
			}
		}

		function displText(a, b) {
			const fs = fieldSize;
			const lon = fs * fs - ((fs - 1) / 2) * (((fs - 1) / 2) - 1) * 2;
			let symbolClear = "&#9633"; // clear square
			symbol = "&#9632"// bflack square
			let dyId = orientation === "landscape" ? "dyL" : "dy";
			//const KDimention = 2.46;
			const KDimention = 2.5;
			document.getElementById(dyId).innerHTML = `<table border=0 cellSpacing=0 cellPadding=0 id="dyTable">
						<tr>
							<td style="width: ${tableWidth}px; font-size: ${tableWidth * KDimention / ((fieldSize + 1) * (fieldSize + 1))}; word-break: break-all;"><span style="color: ${index2Color(firstColorIndex)}">${symbol.repeat(a)}</span><span>${symbolClear.repeat(lon - a - b)}</span><span style="color: ${index2Color(secondColorIndex)}">${symbol.repeat(b)}</span></td>
						</tr>
						<tr>
							<td style="width: ${tableWidth}px; font-size: ${tableWidth * KDimention / ((fieldSize + 1) * (fieldSize + 1))}; word-break: break-all;"><span style="color: ${index2Color(secondColorIndex)}">${symbol.repeat(b)}</span><span>${symbolClear.repeat(lon - a - b)}</span><span style="color: ${index2Color(firstColorIndex)}">${symbol.repeat(a)}</span></td>
						</tr>
					</table>`;
		}

		function displOne(a, b) {
			const fs = fieldSize;
			const lon = fs * fs - ((fs - 1) / 2) * (((fs - 1) / 2) - 1) * 2;

			// Формування рядка поточної партії
			let dif = a - b, col = firstColorIndex, f = 0;
			if (dif < 0) {
				dif = -dif;
				col = secondColorIndex;
				f = 1;
			}
			if (firstColorIndex == -2) {
				f = (f === 0) ? 1 : 0;
			}
			let allVal = 0;
			let currentRow = "";
			if (a + b == lon) {
				gameOver = 1;
				his.push([fieldSize, gameLevel, a, b]);
				saveHis();
				localStorage.removeItem('roboSwitch');
			} else {
				currentRow = `<tr>
					<td align = center>${fs}</td>
					<td bgcolor=${index2Color(col)} align = center><font color="${index2ColorLight(f)}">${gameLevel}</font></td>
					<td align = center>${a}</td>
					<td align = center bgcolor=${index2Color(col)}><font color="${index2ColorLight(f)}">${dif}</font></td>
					<td align = center>${b}</td>
				</tr>`;
				allVal = a - b;
			}

			// Формування історії
			let hisRev = his.slice().reverse();
			let g;
			g = (f === 0) ? 1 : 0;
			f = (firstColorIndex === -2) ? 1 : 0;
			g = (secondColorIndex === -2) ? 1 : 0;
			let txt = `<table border=0 id="statTable">
        		<tr bgcolor="${index2Color(firstColorIndex)}"><td></td><td></td><td></td><td></td><td></td><td></td></tr>
        		<tr>
					<th style="font-size: ${gameLevel * 100}%; color: ${index2ColorLight(firstColorIndex)}"rowspan="${his.length * 2 + 3}" valign = "top">${gameLevel}</th>
            		<th id="size">Size</th>
            		<th id="level">Level</th>
            		<th bgcolor="${index2Color(firstColorIndex)}"><font color="${index2ColorLight(f)}">${lon}</font></th>
           			<th id="all"></th>
            		<th bgcolor="${index2Color(secondColorIndex)}" align="center">
						<font color="${index2ColorLight(g)}">${fs > 7 ? (fs - 2) * (fs - 2) - (((fs - 2) - 1) / 2) * ((((fs - 2) - 1) / 2) - 1) * 2 : 0}</font>
					</th>
        		</tr>
        		<tr bgcolor="${index2Color(2)}"><td></td><td></td><td></td><td></td><td></td></tr>
        		${currentRow}
    		`;

			for (const i of hisRev) {
				let diff = i[2] - i[3], col = firstColorIndex, f = 0;
				allVal += diff;
				if (diff < 0) {
					diff = -diff;
					col = -2;
					f = 1;
				}
				if (firstColorIndex == -2) {
					f = (f === 0) ? 1 : 0;
				}
				txt += `<tr bgcolor="${index2Color(2)}"><td></td><td></td><td></td><td></td><td></td></tr>
        		<tr>
            		<td align="center">${i[0]}</td>
            		<td bgcolor="${index2Color(col)}" align="center"><font color="${index2ColorLight(f)}">${i[1]}</font></td>
            		<td align="center">${i[2]}</td>
            		<td bgcolor="${index2Color(col)}" align="center"><font color="${index2ColorLight(f)}">${diff}</font></td>
            		<td align="center">${i[3]}</td>
        		</tr>`;
			}
			txt += `<tr bgcolor="${index2Color(2)}"><td></td><td></td><td></td><td></td><td></td><td></td></tr></table>`;
			let ntId = orientation === "landscape" ? "ntL" : "nt";
			document.getElementById(ntId).innerHTML = txt;

			// Відображення загального рахунку
			let allValModule = Math.abs(allVal);
			col = allVal < 0 ? secondColorIndex : firstColorIndex;
			let fontK = 1;

			// Автоматична зміна рівня/розміру
			let m = 0;
			if (fs > 7) m = (fs - 2) * (fs - 2) - (((fs - 2) - 1) / 2) * ((((fs - 2) - 1) / 2) - 1) * 2;
			newLevel = 0;
			if (fs > 7 && allVal < m) {
				newLevel = (gameLevel > 1) ? -1 : 0;
				//newLevel = -1;
				document.getElementById("level").bgColor = index2Color(secondColorIndex);
				document.getElementById("size").bgColor = index2Color(secondColorIndex);
				f = (secondColorIndex === -2) ? 1 : 0;
				document.getElementById("level").innerHTML = `<font color="${index2ColorLight(f)}">${document.getElementById("level").innerText}</font>`;
				document.getElementById("size").innerHTML = `<font color="${index2ColorLight(f)}">${document.getElementById("size").innerText}</font>`;
				fontK = 0.5;
			} else
				if (allVal > lon) {
					newLevel = (gameLevel > 0) ? 1 : 0;
					document.getElementById("level").bgColor = index2Color(firstColorIndex);
					document.getElementById("size").bgColor = index2Color(firstColorIndex);
					g = (firstColorIndex === -2) ? 1 : 0;
					document.getElementById("level").innerHTML = `<font color="${index2ColorLight(g)}">${document.getElementById("level").innerText}</font>`;
					document.getElementById("size").innerHTML = `<font color="${index2ColorLight(g)}">${document.getElementById("size").innerText}</font>`;
					fontK = 3;
				}

			// Оновлення відображення all
			f = (col == -1) ? 0 : 1;
			const cell = document.getElementById("all");
			cell.innerHTML = `<font color="${index2ColorLight(f)}">${allValModule}</font>`;
			cell.bgColor = index2Color(col);
			cell.style.fontSize = `${fontK * 100}%`;
			changeSize = 0;
			//document.getElementById("size").style.color = index2Color(1);
		}

		// Robot function to find and click on lines
		function robot(query) {
			const fs = fieldSize;
			firstColorSet();
			// 1. Вибір матриці для аналізу
			let matrix = (query <= 0)
				? (gameColorIndex !== firstColorIndex
					? fieldMatrix.map(row => row.map(val => val === 1 ? 1 : 0))
					: fieldMatrix.map(row => row.slice()))
				: (gameColorIndex == firstColorIndex
					? fieldMatrix.map(row => row.map(val => val === 1 ? 1 : 0))
					: fieldMatrix.map(row => row.slice()));

			// 3. Пошук можливих ліній
			let mxlnv = [], mxlnh = [];
			for (let y = 1; y <= fs; y++) {
				for (let x = 1; x < fs; x++) {
					let xx = 2 * x, yy = 2 * y - 1, z = 0;
					if (
						matrix[yy][xx - 1] === 0 && matrix[yy][xx + 1] === 0 &&
						matrix[yy - 1][xx] === 1 && matrix[yy + 1][xx] === 1 &&
						matrix[yy][xx] === 0
					) {
						mxlnv.push([yy, xx, z]);
					}
				}
			}
			for (let y = 1; y < fs; y++) {
				for (let x = 1; x <= fs; x++) {
					let xx = 2 * x - 1, yy = 2 * y, z = 0;
					if (
						matrix[yy - 1][xx] === 0 && matrix[yy + 1][xx] === 0 &&
						matrix[yy][xx - 1] === 1 && matrix[yy][xx + 1] === 1 &&
						matrix[yy][xx] === 0
					) {
						mxlnh.push([yy, xx, z]);
					}
				}
			}

			// Оцінка ходів (rate)
			const mxln = [...mxlnh, ...mxlnv];// Combine horizontal and vertical lines
			for (const ln of mxlnv) {
				let mxCopy = matrix.map(row => row.slice());
				mxCopy[ln[0]][ln[1]] = 1;
				sqare(mxCopy, ln, ln[0], ln[1] - 1); // left square
				sqare(mxCopy, ln, ln[0], ln[1] + 1); // right square
			}
			for (const ln of mxlnh) {
				let mxCopy = matrix.map(row => row.slice());
				mxCopy[ln[0]][ln[1]] = 1;
				sqare(mxCopy, ln, ln[0] - 1, ln[1]); // top square
				sqare(mxCopy, ln, ln[0] + 1, ln[1]); // bottom square
			}

			// 5. Вибір ходу з мінімальним rate
			if (mxln.length > 0) {
				const ratemin = Math.min(...mxln.map(a => a[2]));// Find minimum rate
				const filtered = (ratemin <= gameLevel * gameLevel || gameLevel === 0 || query === 1)// Filter lines based on game level**2
					? mxln.filter(a => a[2] <= ratemin)
					: mxln;
				optymalMatrix = mxln.filter(a => a[2] <= ratemin);
				const min = 0, max = filtered.length - 1;// Random selection from filtered lines
				const randomInt = Math.floor(Math.random() * (max - min + 1)) + min;// Random index

				// 6. Виконання дії залежно від query
				if (query == 0) {
					clickk(cellId(pref, filtered[randomInt][1] + FS - fs, filtered[randomInt][0] + FS - fs));// click on random line
					robot(10);
				} else if (query == 1) {
					fnBlick(filtered[randomInt][0] + FS - fs, filtered[randomInt][1] + FS - fs);
				} else if (query == 2) {
					if (ratemin == 0 && filtered.length > 5) {
						clickk(cellId(pref, filtered[randomInt][1] + FS - fs, filtered[randomInt][0] + FS - fs));// click on random line
						fnAutoBlick(query);
					}
				} else if (query == -2) {
					clickk(cellId(pref, filtered[randomInt][1] + FS - fs, filtered[randomInt][0] + FS - fs));// click on random line
					fnAutoBlick(query);
				} else if (query == 10) {
					fnReNew(filtered[randomInt][0] + FS - fs, filtered[randomInt][1] + FS - fs);
				}
				if ((query == 2 || query == -2) && ratemin == 0 && filtered.length <= 6) {
					roboSwitch = 0;
					roboColor('vartab');
				}
				if (query == -1) {
					fnBlick(filtered[randomInt][0] + FS - fs, filtered[randomInt][1] + FS - fs);
				}
				if (query == 10) {
					fnStatus(ratemin, filtered.length);
				}
			} else {
				optymalMatrix = [];
				//bounceTable();
			}
			if (query != 10) {
				robot(10);
			}
		}

		// Status function to display the rate and number of available lines
		function fnStatus(rateMin, filteredLength) {
			let symbol = "&#9632"; // black square
			let statId = orientation === "landscape" ? "statL" : "stat";
			let rateCount = rateMin;
			if (rateMin == 0) { symbol = "&#9633"; rateCount = 1; }// white square
			if (rateCount <= 20) {
				document.getElementById(statId).innerHTML = `${symbol.repeat(rateCount)} : ${filteredLength}`;
			} else {
				document.getElementById(statId).innerHTML = `${symbol.repeat(3)}...${symbol.repeat(3)}`;
			}
		}

		async function fnAutoBlick(query) {
			await delay(100);
			robot(-query);
		}

		async function fnBlick(y, x) {
			document.getElementById(cellId(pref, x, y)).bgColor = "#00ff00";// green
			await delay(1000);
			document.getElementById(cellId(pref, x, y)).bgColor = index2Color(fieldMatrix[y + fieldSize - FS][x + fieldSize - FS]);// gray
		}

		async function fnReNew(y, x) {
			await delay(100);
		}

		// Function to handle cell clicks
		function lnCheckV(mx, ln, y, x) {
			sqare(mx, ln, y, x - 1); // left square
			sqare(mx, ln, y, x + 1); // right square
		}

		// Function to check if a square can be formed and update the matrix and line count
		function lnCheckH(mx, ln, y, x) {
			sqare(mx, ln, y - 1, x); // top square
			sqare(mx, ln, y + 1, x); // bottom square
		}

		// Function to check if a square can be formed and update the matrix and line count
		function sqare(mx, ln, ysq, xsq) {
			if (
				ysq > 0 && xsq > 0 &&
				ysq < mx.length - 1 && xsq < mx[0].length - 1
			) {
				const sum =
					Number(mx[ysq - 1][xsq]) +
					Number(mx[ysq + 1][xsq]) +
					Number(mx[ysq][xsq - 1]) +
					Number(mx[ysq][xsq + 1]);
				if (sum === 3) {
					ln[2]++;
					if (Number(mx[ysq - 1][xsq]) === 0) {
						mx[ysq - 1][xsq] = 1;
						lnCheckH(mx, ln, ysq - 1, xsq);
					}
					if (Number(mx[ysq + 1][xsq]) === 0) {
						mx[ysq + 1][xsq] = 1;
						lnCheckH(mx, ln, ysq + 1, xsq);
					}
					if (Number(mx[ysq][xsq - 1]) === 0) {
						mx[ysq][xsq - 1] = 1;
						lnCheckV(mx, ln, ysq, xsq - 1);
					}
					if (Number(mx[ysq][xsq + 1]) === 0) {
						mx[ysq][xsq + 1] = 1;
						lnCheckV(mx, ln, ysq, xsq + 1);
					}
				}
			}
		}

		//
		function roboColor(idTab) {
			roboSwitch = roboSwitch === 0 ? 1 : 0;
			document.getElementById(cellId(pref, 2 * FS - 1, 2 * FS - 1)).bgColor =
				roboSwitch === 1 ? index2Color(2) : index2Color(0);
			saveValue('roboSwitch', roboSwitch);
			writeText();
			if (advanced) {
				document.getElementById("grayBtn").value = gameLevel;
				document.getElementById("grayBtn").style.backgroundColor =
					roboSwitch === 1 ? index2Color(2) : index2Color(0);
			}
			//document.getElementById('qrcodeImg').style.filter = `invert(${darkMode})`;
		}

		// 
		async function autoSet(idTab, fieldSize) {
			for (let j = 0; j < fieldSize; j++) {
				for (let k = 0; k < fieldSize; k++) {
					const y = j * 2 + 1, x = k * 2 + 1;
					const arrCol = AroMatrix(y, x).map(a => Number(a == 1));
					const sum = arrCol.reduce((a, b) => a + b, 0);
					if (sum === 3) {
						let cId = null;
						for (const [yy, xx, value] of AroMatrixYXC(y, x)) {
							if (value !== 1) {
								cId = cellId(pref, xx + FS - fieldSize, yy + FS - fieldSize);
								break;
							}
						}
						if (cId) {
							await delay(100);
							if (gameOver == 0) {
								await clickk(cId);
								await autoSet(idTab, fieldSize);
							}
							return;
						}
					}
				}
			}
			await delay(800);
			if (roboSwitch === 1) await robot(0);
			if (gameOver == 0) {
				bill(fieldSize);
			}
		}

		// Function to get the neighbors of a cell in the matrix
		function AroMatrix(y, x) {
			return [
				fieldMatrix[y - 1]?.[x] === 1,
				fieldMatrix[y + 1]?.[x] === 1,
				fieldMatrix[y]?.[x - 1] === 1,
				fieldMatrix[y]?.[x + 1] === 1
			];
		}

		// Function to get the neighbors of a cell in the matrix
		function AroMatrixYXC(y, x) {
			return [
				[y - 1, x, fieldMatrix[y - 1]?.[x]],
				[y + 1, x, fieldMatrix[y + 1]?.[x]],
				[y, x - 1, fieldMatrix[y]?.[x - 1]],
				[y, x + 1, fieldMatrix[y]?.[x + 1]]
			];
		}

		// 
		function lightGreen() {
			for (let y = 1; y < fieldSize * 2; y += 2) {
				for (let x = 1; x < fieldSize * 2; x += 2) {
					if (
						fieldMatrix[y][x] === 0 &&
						x + y > fieldSize - 2 &&
						x + y < 3 * fieldSize + 2 &&
						-x + y < fieldSize + 2 &&
						x - y < fieldSize + 2
					) {
						document.getElementById(cellId(pref, x + FS - fieldSize, y + FS - fieldSize)).bgColor =
							greenVar === 1 ? lightGreenColor : index2Color(0);// white or light green
					}
				}
			}
		}

		// 
		function darkGreen() {
			for (let y = 0; y < fieldSize * 2 + 1; y += 1) {
				for (let x = 0; x < fieldSize * 2 + 1; x += 1) {
					if (
						fieldMatrix[y][x] === 1
					) {
						document.getElementById(cellId(pref, x + FS - fieldSize, y + FS - fieldSize)).bgColor =
							greenVar === 1 ? darkGreenColor : index2Color(1);// black or dark green
					}
				}
			}
		}

		// Function to pause the game
		async function gamePause() {
			greenVar = 1;
			lightGreen();
			darkGreen();
			await delay(delayTime);
			greenVar = 0;
			lightGreen();
			darkGreen();
		}

		function firstColorSet() {
			firstColorIndex = Number(getValue('firstColorIndex', firstColorIndex));
			secondColorIndex = Number(getValue('secondColorIndex', secondColorIndex));
			if (firstColorIndex === 0) {
				firstColorIndex = gameColorIndex;
				secondColorIndex = (firstColorIndex === -1) ? -2 : -1;
			}
			saveValue('firstColorIndex', firstColorIndex);
			saveValue('secondColorIndex', secondColorIndex);
		}

		// Function to handle clicks on the game board
		async function clickh(nam) {
			let y = parseInt(nam.substr(1, 2), 10);
			let x = parseInt(nam.substr(3, 2), 10);
			let X = x - FS + fieldSize;
			let Y = y - FS + fieldSize;
			if (fieldMatrix[Y][X] == 2) {
				if (greenVar === 0 && gameOver === 0) {
					await clickk(nam);
					if (roboSwitch === 1) gamePause();
				}
				changeSize = 1;
			}
		}
		// Function to handle clicks on the game board 
		function clickk(nam) {
			const fs = fieldSize;
			const Bor = document.getElementById(nam);
			const ny = Number(nam.substr(1, 2));
			const nx = Number(nam.substr(3, 2));
			const nX = nx - FS + fieldSize;
			const nY = ny - FS + fieldSize;

			if (fieldMatrix[nY][nX] === 2) {
				fieldMatrix[nY][nX] = 1;
				Bor.bgColor = index2Color(1);

				firstColorSet();
				// ������� ����� ����� � ����� ��������� (rate)
				const arrMatrix = nY % 2 === 1
					? [[nY, nX - 1, 0], [nY, nX + 1, 0]]
					: [[nY - 1, nX, 0], [nY + 1, nX, 0]];
				// ���������� ����� �� ������������
				let refill = 0;// ��������� ��� ��������������
				for (const ln of arrMatrix) {// ln[0] - y, ln[1] - x
					const y = ln[0], x = ln[1];// ���������� �����
					const sum = AroMatrix(y, x).reduce((a, b) => a + Number(b), 0);// ���� �����
					if (sum == 4) {// ���� �� ����� ���������
						fieldMatrix[y][x] = gameColorIndex;// ���������� �����
						refill = 1;// ��������� ��� ��������������
						document.getElementById(cellId(pref, x + FS - fieldSize, y + FS - fieldSize)).bgColor = index2Color(gameColorIndex);// ������� ���� �����
					}
				}
				// ����������, �� ������� ��������� �����
				autoSet(idTab, fs);
				if (refill === 0) { colsel(pref + "0101"); }
			}
			bill(fs);
		}

		// Function to toggle the color selection
		function colsel(id) {
			firstColorIndex = Number(getValue('firstColorIndex', firstColorIndex));
			secondColorIndex = Number(getValue('secondColorIndex', secondColorIndex));
			if (firstColorIndex === 0) {
				secondColorIndex = gameColorIndex;
				firstColorIndex = (secondColorIndex === -1) ? -2 : -1;
			}
			gameColorIndex = (gameColorIndex === firstColorIndex) ? secondColorIndex : firstColorIndex; // toggle between blue and yellow
			document.getElementById(id).bgColor = index2Color(gameColorIndex);
			let f;
			if (gameColorIndex == -1) {
				f = 0;
			} else {
				f = 1;
			}
			document.getElementById(id).innerHTML = `<font color=${index2Color(f)}>${document.getElementById(id).innerText}</font>`;
			saveValue('firstColorIndex', firstColorIndex);
			saveValue('secondColorIndex', secondColorIndex);
		}

		function hasCookie(name) {
			return document.cookie.split(';').some((item) => item.trim().startsWith(name + '='));
		}

		function saveValue(name, value) {
			localStorage.setItem(name, value);
		}

		function getValue(name, defaultValue) {
			const value = localStorage.getItem(name);
			return value !== null ? value : defaultValue;
		}

		function writeMatrix() {
			// Зберегти матрицю
			localStorage.setItem('fieldMatrix', JSON.stringify(fieldMatrix));
		}

		function readMatrix() {
			// Отримати матрицю
			fieldMatrix = JSON.parse(localStorage.getItem('fieldMatrix') || '[]');
		}

		function saveHis() {
			localStorage.setItem('his', JSON.stringify(his));
		}

		function getHis() {
			// Отримати матрицю
			his = JSON.parse(localStorage.getItem('his') || JSON.stringify(his));
		}

		// Function to create the HTML structure for the game board
		function createHtml(fs, FS, change) {
			let html = [];
			let cellWidth;
			let cellHeight;
			fieldMatrix = Array.from({ length: FS * 2 + 2 }, () => Array(FS * 2 + 1).fill(0));
			if (change == 0 && localStorage.getItem('fieldMatrix') !== null) {
				readMatrix();
			}
			let dF = FS - fs
			html.push(`<TABLE border=0 cellSpacing=0 id="vartab" style="table-layout: fixed; border-collapse: collapse; width: ${tableWidth}px; height: ${tableWidth}px;">`);
			for (let y = 0; y < FS * 2 + 1; y++) {
				html.push(`<TR style="height:${y % 2 == 1 ? linesWidth : linesWidth / 10}px;">`);
				for (let x = 0; x < FS * 2 + 1; x++) {
					X = x - dF; Y = y - dF;
					let td = `<TD id="${cellId(pref, x, y)}" bgcolor="`;
					let ck = 0;
					// Визначаємо колір клітинки
					if (x == 2 * FS - 1 && y == 2 * FS - 1) { td += index2Color(roboSwitch === 1 ? 2 : 0); } //gray or white
					else if (x == 1 && y == 1) { td += index2Color(-1); } // blue
					else if (x % 2 == 1 && y % 2 == 1) { td += index2Color(x >= dF && y >= dF && x <= 2 * FS - dF && y <= 2 * FS - dF ? fieldMatrix[Y < 0 || Y > 2 * fs ? 0 : Y][X < 0 || X > 2 * fs ? 0 : X] : 0); } // white square
					else if ((x % 2 == 0 && y % 2 == 0
						&& X + Y >= fs - 3 && X + Y <= (3 * fs) + 3
						&& ((-X + Y) <= (fs + 3)) && ((X - Y) <= (fs + 3))
						&& Y >= 0 && X >= 0 && Y <= fs * 2 && X <= fs * 2
					) || (x >= dF && y >= dF
						&& x <= 2 * FS - dF && y <= 2 * FS - dF
						&& (fieldMatrix[Y < 0 || Y > 2 * fs ? 0 : Y][X < 0 || X > 2 * fs ? 0 : X] === 1))
					) { td += index2Color(1); ck = 2; } // black lines & dots
					else if ((false
						|| (X + Y == fs - 2) || (-X + Y == fs + 2)
						|| (X - Y == fs + 2) || (X + Y == (3 * fs + 2))
						|| (X == fs && Y == 0) || (X == fs && Y == 2 * fs)
						|| (X == 0 && Y == fs) || (X == 2 * fs && Y == fs)
					) && Y >= 0 && X >= 0 && Y <= fs * 2 && X <= fs * 2) { td += index2Color(1); }// black perimeter 
					else { td += index2Color(2); ck = 1; }// gray # area
					td += '"';
					cellWidth = (x % 2 == 1 ? linesWidth : linesWidth / 10);
					cellHeight = (y % 2 == 1 ? linesWidth : linesWidth / 10);
					td += ` style="width:${cellWidth}px; height:${cellHeight}px; max-height:${cellHeight}px; min-height:${cellHeight}px; padding:0px; margin:0px; border:0px; font-size:${tableWidth / (1.5 * FS)}px; line-height:${cellHeight}px; overflow:hidden; vertical-align:middle; white-space: nowrap;"`;
					td += ' onclick="';
					// Призначаємо події
					if (x == 1 && y == 1) { td += "colsel('" + pref + "0101')"; } // blue
					else if (x == 3 && y == 1) { td += advanced ? "fnChanger(2)" : ""; }//+
					else if (x == 1 && y == 3) { td += advanced ? "fnChanger(-2)" : ""; }//-
					else if (x == FS * 2 - 1 && y == FS * 2 - 3) { td += advanced ? "fnLevel(1)" : ""; } //+
					else if (x == FS * 2 - 3 && y == FS * 2 - 1) { td += advanced ? "fnLevel(-1)" : ""; } //-
					else if (x == 3 && y == FS * 2 - 1) { td += advanced ? "fnNewGame()" : ""; } //#
					else if (x == 1 && y == FS * 2 - 1) { td += "fnAuto()"; } //>
					else if ((X + Y === fs - 3 || X + Y == 3 * fs + 3 || -X + Y == fs + 3 || X - Y == fs + 3) && Y >= 0 && X >= 0 && Y <= fs * 2 && X <= fs * 2 && x % 2 == 1 && y % 2 == 1) { td += advanced ? "fnQuery()" : ""; }
					else if (x == (2 * FS - 1) && y == 1) { td += advanced ? "robot(0)" : ""; }
					else if (x == 2 * FS - 1 && y == 2 * FS - 1) { td += advanced ? "roboColor('vartab')" : ""; }
					else if (ck == 1 && X + Y > fs - 4 && X + Y < 3 * fs + 4 && -X + Y < fs + 4 && X - Y < fs + 4) { td += "clickh('" + cellId(pref, x, y) + "')"; }
					else if (ck != 2 && X + Y > fs - 4 && X + Y < 3 * fs + 4 && -X + Y < fs + 4 && X - Y < fs + 4) { matrixCell.push(cellId(pref, x, y)); }
					else if (x == FS * 2 - 3 && y == 1) { td += advanced ? "fnWorm()" : ""; } //W
					else if (x == FS * 2 - 1 && y == 3) { td += advanced ? "fnSnake()" : ""; } //S
					else if (x == 1 && y == FS * 2 - 3 && FS > 7) { td += "resetGame()"; }//R
					td += '"';
					td += ' align="center" valign="middle">';
					// Символи
					if ((x == 1 && y == 1)) { td += `<font color=${index2Color(0)}>${fs}</font>`; }
					else if (x == 3 && y == 1) { td += advanced ? "+" : ""; }
					else if (x == 1 && y == 3) { td += advanced ? "-" : ""; }
					else if (x == FS * 2 - 1 && y == FS * 2 - 3) { td += advanced ? "+" : ""; }
					else if (x == FS * 2 - 3 && y == FS * 2 - 1) { td += advanced ? "-" : ""; }
					else if (x == 1 && y == FS * 2 - 1) { td += '>' }
					else if (x == 3 && y == FS * 2 - 1) { td += advanced ? '#' : '' }
					else if ((X + Y === fs - 3 || X + Y == 3 * fs + 3 || -X + Y == fs + 3 || X - Y == fs + 3) && Y >= 0 && X >= 0 && Y <= fs * 2 && X <= fs * 2 && x % 2 == 1 && y % 2 == 1) { td += advanced ? '?' : '' }
					else if (x == FS * 2 - 3 && y == 1) { td += advanced ? 'W' : ''; }
					else if (x == FS * 2 - 1 && y == 3) { td += advanced ? 'S' : ''; }
					else if (x == FS * 2 - 1 && y == FS * 2 - 1) { td += gameLevel; }
					else if (x == 1 && y == FS * 2 - 3 && FS > 7) { td += 'R' }
					td += '</TD>';
					html.push(td);
				}
				html.push('</TR>');
			}
			html.push('</TABLE>');
			return html.join('');
		}

		// Initial call to set up the game board
		function writeHtml(change) {
			advanced = Number(getValue("advanced", 0));
			//document.body.style.backgroundColor = index2Color(0);
			document.body.style.color = index2Color(1);
			lightGreenColor = index2Color(10); // light green
			darkGreenColor = index2Color(11); // dark green
			tableWidth = Math.min(window.innerWidth, window.innerHeight) * 0.95;
			FS = Number(getValue("FS", 7));
			roboSwitch = Number(getValue("roboSwitch", roboSwitch));
			fieldSize = Number(getValue("fieldSize", 7));
			const fs = fieldSize;
			gameLevel = Number(getValue('level', gameLevel));
			getHis();
			matrixCell = []; // Очищення
			document.getElementById("column1").style.width = `${24 * FS + 20}px`;

			// Оновлення ігрового поля
			document.getElementById("tc").innerHTML = createCoordX(fs);//X axis
			document.getElementById("tv").innerHTML = createCoordY(fs);//Y axis
			document.getElementById("tx").innerHTML = createHtml(fs, FS, change);//Game Board

			displText(0, 0);
			grayCellId = cellId(pref, FS * 2 - 1, FS * 2 - 1);

			// Створення fieldMatrix нового розміру
			fieldMatrix = Array.from({ length: 2 * fs + 1 }, (_, y) =>
				Array.from({ length: 2 * fs + 1 }, (_, x) => {
					const col = document.getElementById(cellId(pref, x + FS - fieldSize, y + FS - fieldSize)).bgColor;
					return col === index2Color(1) ? 1 : col === index2Color(2) ? 2 : col === index2Color(-1) ? -1 : col === index2Color(-2) ? -2 : 0;
				})
			);

			// Делегування подій для кліків (опціонально)
			//document.getElementById("vartab").onclick = function (e) {
			//	if (e.target.tagName === "TD") handleCellClick(e.target);
			//};

			// Додаємо обробники кліків для кожної клітинки
			matrixCell.forEach(id => {
				const cell = document.getElementById(id);
				// Замість addEventListener можна використовувати onclick, щоб не накопичувати події:
				cell.onclick = function (e) {
					const rect = this.getBoundingClientRect();
					const x = e.clientX - rect.left;
					const y = e.clientY - rect.top;
					const w = rect.width, h = rect.height;

					// Діагоналі: y = x (головна), y = h - x (побічна)
					if (y < x && y < h - x) { clickh(getNeighborCellId(id, -1, 0)); } // up
					else if (y < x && y >= h - x) { clickh(getNeighborCellId(id, 0, 1)); } // right
					else if (y >= x && y < h - x) { clickh(getNeighborCellId(id, 0, -1)); } // left
					else if (y >= x && y >= h - x) { clickh(getNeighborCellId(id, 1, 0)); }// down
				};
			});
			if (his.length > 0) { firstColorSet(); }
			document.body.style.backgroundColor = index2Color(0);
			//alert(index2Color(-1));
			robot(0);
			bill(fs);
			writeText()
			if (advanced) {
				document.getElementById("grayBtn").value = gameLevel;
			}
			document.getElementById("bottomTable").style.width = `${tableWidth}px`;
		}

		let cellWidthQ = 0;

		function writeText() {
			let symbol = "&#9632"; // black square
			let textingId = orientation == "landscape" ? "textingL" : "texting";
			let cellId = orientation == "landscape" ? "textingCellL" : "textingCell";
			let cell = document.getElementById(cellId);
			let baseWidth = cell ? cell.offsetWidth : 100;
			if (cellWidthQ == 0) {
				cellWidthQ = orientation == "landscape" ? baseWidth * 2 : baseWidth * 1;
			}
			document.getElementById(textingId).innerHTML = `<img src="qrcode.gif" id="qrcodeImg" style="width:${cellWidthQ}px; height:${cellWidthQ}px" alt="QR Code" align="left">`;
			document.getElementById(textingId).innerHTML += `<br>Changing the color palette <img src="${colorPalette == 0 ? 'xoxr.png' : 'xox.png'}" id="xoxpng" alt="Col" align="left" onclick="changeColorPalette()">`;
			document.getElementById(textingId).innerHTML += `<br><span style="color: ${index2Color(firstColorIndex)}">&#9632</span> is ${roboSwitch == 1 ? 'your' : 'first gamer'} color`;
			document.getElementById(textingId).innerHTML += `<br><span style="color: ${index2Color(secondColorIndex)}">&#9632</span> is ${roboSwitch == 1 ? 'robot' : 'second gamer'} color`;
			document.getElementById(textingId).innerHTML += `<br><span style="color: ${index2Color(firstColorIndex)}; font-weight: bold;">${gameLevel}</span> is game level`;
			document.getElementById(textingId).innerHTML += '<br>Try pressing <input type="button" value=">" onclick="fnAuto()" id="autoBtn1" style="width: 30px; height: 30px; font-size: 24px;"> to get started. The first moves will be automatic.';
			document.getElementById(textingId).innerHTML += '<br>The goal is to get more squares of your color to move to a higher level and board size.';
			document.getElementById(textingId).innerHTML += `<br>${darkMode === 0 ? "Dark" : "Light"} mode <input type="button" value="${darkMode === 0 ? "&#9790" : "&#9728"};" onclick="fnDarkMode()" id="darkBtn" style="width: 30px; height: 30px; font-size: 24px;"> toggle.`;
			document.getElementById(textingId).innerHTML += `<hr>`;
			document.getElementById(textingId).innerHTML += `${advanced ? `Click on the gray square <input type="button" value="1" onclick="roboColor('vartab')" id="grayBtn" style="width: 30px; height: 30px; font-size: 24px;background-color:#eee; border:none;"> to toggle the robot on/off.` : ``}`;
			document.getElementById(textingId).innerHTML += `${advanced ? `<br>${darkMode === 0 ? "White" : "Black"} square <input type="button" value=" " onclick="robot(0)" id="whiteBtn" style="width: 30px; height: 30px; font-size: 24px; background-color:#fff;"> in the upper right corner - robot progress.` : ``}`;
			document.getElementById(textingId).innerHTML += `${advanced ? `<br><input type="button" value="?" onclick="fnQuery()" id="hintBtn" style="width: 30px; height: 30px; font-size: 24px;"> - Hint` : ``}`;
			document.getElementById(textingId).innerHTML += `${advanced ? `<br><input type="button" value="S" onclick="fnSnake()" id="snakeBtn" style="width: 30px; height: 30px; font-size: 24px;"> - A wise snake that crawls through a maze and finds successful moves` : ``}`;
			document.getElementById(textingId).innerHTML += `${advanced ? `<br>` : ``}<input type="button" value="R" onclick="resetGame()" id="rBtn" style="width: 30px; height: 30px; font-size: 24px;"> - Full reset of the entire game`;
			document.getElementById(textingId).innerHTML += `<input type="button" onclick="bounceTable()" value="&#x21bb;" title="Bounce the table"style="width: 30px; height: 30px; font-size: 24px; margin-top: 10px;">`;
			document.getElementById(textingId).innerHTML += `<br>${advanced ? "Simple" : "Advanced"} <input type="button" onclick="fnAdvanced()" value=${advanced ? "&#9632;" : "&#9881;"} title="Advanced mode"style="width: 30px; height: 30px; font-size: 24px; margin-top: 10px;"> mode for ${advanced ? "beginers" : "experienced players"}.`;
			document.getElementById(textingId).style.color = index2Color(1);
			const qr = document.getElementById('qrcodeImg');
			if (qr) qr.style.filter = `invert(${darkMode})`;
		}

		function changeColorPalette() {
			colorPalette = colorPalette == 0 ? 1 : 0;
			saveValue('colorPalette', colorPalette);
			writeHtml(0);
		}

		function fnDarkMode() {
			darkMode = darkMode == 0 ? 1 : 0;
			saveValue('darkMode', darkMode);
			writeHtml(0);
			document.getElementById('vartab').style.color = index2Color(1);
			document.getElementById('dyTable').style.color = index2Color(1);
			document.getElementById('statTable').style.color = index2Color(1);
			document.getElementById('stat').style.color = index2Color(1);
			document.getElementById('statL').style.color = index2Color(1);
			//document.body.style.backgroundColor = index2Color(1);
			if (advanced) {
				document.getElementById('coordtabX').style.color = index2Color(1);
				document.getElementById('coordtabY').style.color = index2Color(1);
			}
			//document.getElementById('qrcodeImg').style.filter = `invert(${darkMode})`;
		}

		// Function to create the display area for the game
		function createDisplOne(fs) {
			const dimen = fs * fs - ((fs - 1) / 2) * (((fs - 1) / 2) - 1) * 2;
			const html = [];
			html.push(`<TABLE WIDTH="${24.3 * FS}" HEIGHT="12" BORDER="0" CELLSPACING="1" CELLPADDING="1" bgcolor="#ffffff" id="displt">`);
			html.push('<TR>');
			for (let i = 0; i < dimen; i++) {
				html.push(`<TD id="${cellIdL("e", i, 0)}" bgcolor="${index2Color(2)}"></TD>`);
			}
			html.push('<TR>');
			html.push('</TR>');
			for (let i = 0; i < dimen; i++) {
				html.push(`<TD id="${cellIdL("f", i, 0)}" bgcolor="${index2Color(2)}"></TD>`);
			}
			html.push('</TR></TABLE>');
			return html.join('');
		}

		// Event listener to call writeHtml when the document is loaded
		document.addEventListener('DOMContentLoaded', function () { writeHtml(0); });

		// Helper function to generate cell IDs
		function getNeighborCellId(cellId, dy, dx) {
			let y = parseInt(cellId.substr(1, 2), 10);
			let x = parseInt(cellId.substr(3, 2), 10);
			let Y = y - FS + fieldSize;
			let X = x - FS + fieldSize;
			if (fieldMatrix[Y + dy][X + dx] === 1) {
				if (fieldMatrix[Y - dy][X - dx] === 1) {
					[dx, dy] = [dy, dx];// swap
				} else if (fieldMatrix[Y + dy][X - dx] === 1) {
					dy = -dy;
				} else if (fieldMatrix[Y - dy][X + dx] === 1) {
					dx = -dx;
				}
			}
			let newY = (y + dy).toString().padStart(2, '0');
			let newX = (x + dx).toString().padStart(2, '0');
			return pref + newY + newX;
		}

		function changeLevel() { gameLevel = Number(document.getElementById("flevel").value); }

		let x = 0, y = 0, colorX = [], coord = [], i = 0, dx = 0, dy = 0, wLength = 7, wormColor = "#0033ff";

		async function fnWorm() {
			colorX[i] = document.getElementById(cellId(pref, x + 0, y + 0)).bgColor;
			coord[i] = cellId(pref, x, y);
			document.getElementById(coord[i]).bgColor = document.getElementById("v0101").bgColor;
			if (i > wLength + 1) { document.getElementById(coord[i - 2 - wLength]).bgColor = colorX[i - 2 - wLength]; }
			if (x < fieldSize * 2 && y == 0) {
				dx = 1; dy = 0;
			} else if (y < fieldSize * 2 && x == fieldSize * 2) {
				dx = 0; dy = 1;
			} else if (y == fieldSize * 2 && x > 0) {
				dx = -1; dy = 0;
			} else { dx = 0; dy = -1; }
			x = x + dx; y = y + dy; i++;
			if (i % 2 == 0) { await delay(400); }
			fnWorm();
		}

		let cYX = [], xs = 1, ys = 1, is = 0;

		let snakeMatrix = [], N, M;

		async function fnSnake() {
			N = 7; M = N;
			snake = (snake == 0) ? 1 : 0;
			blickMatrix = [];
			if (snake != 0) {
				fnSnakeII(0, 1);
			}
		}

		async function fnSnakeII(deltaYold, deltaXold) {
			let deltaY = 0, deltaX = 0, delayMs = 120;
			if (is == 0) { xs = 0; ys = 0; snakeMatrix = []; deltaY = 0; deltaX = 1; }
			else {
				let stepMatrixOver = [];
				let stepMatrix = [];
				let stepMatrixLabirint = [];
				let exists;
				deltaY = 1; deltaX = 0;
				if (ys + deltaY < fieldSize / 2 + 0.5
					&& xs + deltaX < fieldSize / 2
					&& ys + deltaY > -fieldSize / 2
					&& xs + deltaX > -fieldSize / 2
					&& ys + deltaY + xs + deltaX >= -fieldSize / 2 - 1
					&& ys + deltaY + xs + deltaX <= fieldSize / 2 + 1
					&& -ys - deltaY + xs + deltaX >= -fieldSize / 2 - 1
					&& ys + deltaY - xs - deltaX >= -fieldSize / 2 - 1
				) {
					exists = snakeMatrix.some(item => item[0] === ys + deltaY && item[1] === xs + deltaX);
					if (!exists) {
						if (fieldMatrix[(ys + deltaY) * 2 + fieldSize][(xs + deltaX) * 2 + fieldSize] == 0) {
							stepMatrix.push([ys + deltaY, xs + deltaX]);
							if (fieldMatrix[(ys + deltaY) * 2 + fieldSize - deltaY][(xs + deltaX) * 2 + fieldSize - deltaX] == 2) {
								stepMatrixLabirint.push([ys + deltaY, xs + deltaX]);
							}
						} else {
							stepMatrixOver.push([ys + deltaY, xs + deltaX]);
						}
					}
				}
				deltaY = -1; deltaX = 0;
				if (ys + deltaY < fieldSize / 2 + 0.5
					&& xs + deltaX < fieldSize / 2
					&& ys + deltaY > -fieldSize / 2
					&& xs + deltaX > -fieldSize / 2
					&& ys + deltaY + xs + deltaX >= -fieldSize / 2 - 1
					&& ys + deltaY + xs + deltaX <= fieldSize / 2 + 1
					&& -ys - deltaY + xs + deltaX >= -fieldSize / 2 - 1
					&& ys + deltaY - xs - deltaX >= -fieldSize / 2 - 1
				) {
					exists = snakeMatrix.some(item => item[0] === ys + deltaY && item[1] === xs + deltaX);
					if (!exists) {
						if (fieldMatrix[(ys + deltaY) * 2 + fieldSize][(xs + deltaX) * 2 + fieldSize] == 0) {
							stepMatrix.push([ys + deltaY, xs + deltaX]);
							if (fieldMatrix[(ys + deltaY) * 2 + fieldSize - deltaY][(xs + deltaX) * 2 + fieldSize - deltaX] == 2) {
								stepMatrixLabirint.push([ys + deltaY, xs + deltaX]);
							}
						} else {
							stepMatrixOver.push([ys + deltaY, xs + deltaX]);
						}
					}
				}
				deltaY = 0; deltaX = 1;
				if (ys + deltaY < fieldSize / 2 + 0.5
					&& xs + deltaX < fieldSize / 2
					&& ys + deltaY > -fieldSize / 2
					&& xs + deltaX > -fieldSize / 2
					&& ys + deltaY + xs + deltaX >= -fieldSize / 2 - 1
					&& ys + deltaY + xs + deltaX <= fieldSize / 2 + 1
					&& -ys - deltaY + xs + deltaX >= -fieldSize / 2 - 1
					&& ys + deltaY - xs - deltaX >= -fieldSize / 2 - 1
				) {
					exists = snakeMatrix.some(item => item[0] === ys + deltaY && item[1] === xs + deltaX);
					if (!exists) {
						if (fieldMatrix[(ys + deltaY) * 2 + fieldSize][(xs + deltaX) * 2 + fieldSize] == 0) {
							stepMatrix.push([ys + deltaY, xs + deltaX]);
							if (fieldMatrix[(ys + deltaY) * 2 + fieldSize - deltaY][(xs + deltaX) * 2 + fieldSize - deltaX] == 2) {
								stepMatrixLabirint.push([ys + deltaY, xs + deltaX]);
							}
						} else {
							stepMatrixOver.push([ys + deltaY, xs + deltaX]);
						}
					}
				}
				deltaY = 0; deltaX = -1;
				if (ys + deltaY < fieldSize / 2 + 0.5
					&& xs + deltaX < fieldSize / 2
					&& ys + deltaY > -fieldSize / 2
					&& xs + deltaX > -fieldSize / 2
					&& ys + deltaY + xs + deltaX >= -fieldSize / 2 - 1
					&& ys + deltaY + xs + deltaX <= fieldSize / 2 + 1
					&& -ys - deltaY + xs + deltaX >= -fieldSize / 2 - 1
					&& ys + deltaY - xs - deltaX >= -fieldSize / 2 - 1
				) {
					exists = snakeMatrix.some(item => item[0] === ys + deltaY && item[1] === xs + deltaX);
					if (!exists) {
						if (fieldMatrix[(ys + deltaY) * 2 + fieldSize][(xs + deltaX) * 2 + fieldSize] == 0) {
							stepMatrix.push([ys + deltaY, xs + deltaX]);
							if (fieldMatrix[(ys + deltaY) * 2 + fieldSize - deltaY][(xs + deltaX) * 2 + fieldSize - deltaX] == 2) {
								stepMatrixLabirint.push([ys + deltaY, xs + deltaX]);
							}
						} else {
							stepMatrixOver.push([ys + deltaY, xs + deltaX]);
						}
					}
				}
				if (stepMatrixLabirint.length == 0) {
					if (stepMatrix.length == 0) {
						deltaY = 0;
						deltaX = 1;
						xs = 0;
						ys = 0;
						///////////
						let a = 0, cellFree = [];
						for (let j = 0; j < fieldSize; j++) {
							for (let k = 0; k < fieldSize; k++) {
								const val = fieldMatrix[j * 2 + 1][k * 2 + 1];
								if (!((j * 2 + 1) === 1 && (k * 2 + 1) === 1)) {
									if (val === firstColorIndex || val === secondColorIndex) { a++; }
								}
							}
						}
						if (stepMatrixOver.length > 0) {
							const randomInt = Math.floor(Math.random() * (stepMatrixOver.length));
							ys = +stepMatrixOver[randomInt][0];
							xs = +stepMatrixOver[randomInt][1];
						}
						if (a < fieldSize * fieldSize - ((fieldSize - 1) / 2) * (((fieldSize - 1) / 2) - 1) * 2) {
						} else {
							snake = 0;
						}
						////////////
					} else {
						const randomInt = Math.floor(Math.random() * (stepMatrix.length));
						ys = +stepMatrix[randomInt][0];
						xs = +stepMatrix[randomInt][1];
					}
				} else {
					const randomInt = Math.floor(Math.random() * (stepMatrixLabirint.length));
					ys = +stepMatrixLabirint[randomInt][0];
					xs = +stepMatrixLabirint[randomInt][1];
				}

			}
			snakeMatrix.push([ys, xs]);
			snakeMatrix = snakeMatrix.slice(-N);

			for (let k = 0; k < snakeMatrix.length; k++) {
				let pos = snakeMatrix[k];
				if (k < M) {
					document.getElementById(cellId(pref, pos[1] * 2 + FS, pos[0] * 2 + FS)).bgColor = adjustColor(index2Color(fieldMatrix[pos[0] * 2 + fieldSize][pos[1] * 2 + fieldSize]), 70 * k / snakeMatrix.length);
				}
			}
			if (snake == 0) { M--; } else {
				let [optymalY, optymalX] = snakeMatrix[snakeMatrix.length - 1];
				optymalY = optymalY * 2 + fieldSize;
				optymalX = optymalX * 2 + fieldSize;
				if (optymalMatrix.some(item => item[0] === optymalY + 1 && item[1] === optymalX)) {
					if (blickMatrix.some(item => item[0] === optymalY + 1 && item[1] === optymalX) == false) {
						fnBlick(optymalY + 1 + (FS - fieldSize), optymalX + (FS - fieldSize));
					}
				}
				if (optymalMatrix.some(item => item[0] === optymalY - 1 && item[1] === optymalX)) {
					if (blickMatrix.some(item => item[0] === optymalY - 1 && item[1] === optymalX) == false) {
						fnBlick(optymalY - 1 + (FS - fieldSize), optymalX + (FS - fieldSize));
					}
				}
				if (optymalMatrix.some(item => item[0] === optymalY && item[1] === optymalX + 1)) {
					if (blickMatrix.some(item => item[0] === optymalY && item[1] === optymalX + 1) == false) {
						fnBlick(optymalY + (FS - fieldSize), optymalX + 1 + (FS - fieldSize));
					}
				}
				if (optymalMatrix.some(item => item[0] === optymalY && item[1] === optymalX - 1)) {
					if (blickMatrix.some(item => item[0] === optymalY && item[1] === optymalX - 1) == false) {
						fnBlick(optymalY + (FS - fieldSize), optymalX - 1 + (FS - fieldSize));
					}
				}
				blickMatrix.push([optymalY + 1, optymalX]);
				blickMatrix.push([optymalY - 1, optymalX]);
				blickMatrix.push([optymalY, optymalX + 1]);
				blickMatrix.push([optymalY, optymalX - 1]);
				blickMatrix = blickMatrix.slice(-N * 30);// очищення
			}
			is++;
			await delay(delayMs);
			if (M > 0) {
				fnSnakeII(deltaY, deltaX);
			}
		}

		// Функція для автоматичного затемнення або освітлення кольору
		function adjustColor(hex, percent = 20) {
			// Видаляємо # якщо є
			hex = hex.replace(/^#/, '');
			// Перетворюємо в числа
			let r = parseInt(hex.substring(0, 2), 16);
			let g = parseInt(hex.substring(2, 4), 16);
			let b = parseInt(hex.substring(4, 6), 16);

			// Визначаємо яскравість (перцептивна формула)
			let brightness = 0.299 * r + 0.587 * g + 0.114 * b;

			// Якщо світлий — затемнюємо, якщо темний — освітлюємо
			if (brightness > 186) {
				// Темнішаємо
				r = Math.max(0, r - Math.round(r * percent / 100));
				g = Math.max(0, g - Math.round(g * percent / 100));
				b = Math.max(0, b - Math.round(b * percent / 100));
			} else {
				// Світлішаємо
				r = Math.min(255, r + Math.round((255 - r) * percent / 100));
				g = Math.min(255, g + Math.round((255 - g) * percent / 100));
				b = Math.min(255, b + Math.round((255 - b) * percent / 100));
			}

			// Повертаємо у форматі #rrggbb
			return "#" + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
		}

		// Приклад використання:
		//let newColor = adjustColor("#aabbcc"); // автоматично зробить світліший або темніший

		function fnQuery() { robot(1); }// Call the robot function with query = 1

		async function fnAuto() {
			if (gameOver == 1) {
				bounceTable();
				await delay(2000); // Чекаємо завершення анімації (час має відповідати bounceTable)
				fnNewGame();
				await delay(150);   // Дати DOM оновитися (можна збільшити до 100-150 при потребі)
				fnAuto();          // Запускаємо автоматичні ходи вже у новій грі
				return;
			}
			//bounceTable();
			await delay(200);
			roboSwitch = 0;
			document.getElementById(grayCellId).bgColor = roboSwitch == 1 ? index2Color(0) : index2Color(2);
			robot(2);
		}

		async function fnChanger(delta) {
			if (changeSize == 0) {
				fieldSize = fieldSize + delta;
				if (delta > 0 && FS < fieldSize) { FS = fieldSize; }
				saveValue("fieldSize", fieldSize);
				saveValue("FS", FS);
				writeMatrix();
				writeHtml(1);
			}
		}

		function fnLevel(delta) {
			if (gameLevel > 0 || delta > 0) {
				gameLevel = gameLevel + delta;
				document.getElementById(cellId("v", FS * 2 - 1, FS * 2 - 1)).innerText = gameLevel;
				saveValue("level", gameLevel);
			}
		}

		function fnNewGame() {
			let id = cellId("v", "01", "01");
			if (changeSize == 0) {
				gameOver = 0;
				gameColorIndex = firstColorIndex;
				document.getElementById(id).bgColor = index2Color(gameColorIndex);
				let f = 0;
				if (gameColorIndex == secondColorIndex) {
					f = 1;
				}
				document.getElementById(id).innerHTML = `<font color=${index2Color(f)}>${document.getElementById(id).innerText}</font>`;
				greenVar = 0;
				roboSwitch = 0;
				if (newLevel > 0) {
					fnChanger(2);
					fnLevel(1);
					newLevel = 0;
					//writeHtml(0);
				} else if (newLevel < 0) {
					fnChanger(-2);
					fnLevel(-1);
					newLevel = 0;
				} else {
					//writeHtml(0);
				}
			}
			writeHtml(0);
		}

		function createCoordX(fs) {
			let html = [];
			html.push('<TABLE border=0 cellSpacing=0 id="coordtabX">');
			html.push('<TR>');
			for (let x = 0; x < FS * 2 + 1; x++) {
				html.push(`<TD style="width:${x % 2 == 1 ? 10 * linesWidth : 0}px; font-size: ${tableWidth / (6.0 * FS)}; height: "${linesWidth}px" align="center" valign="down">`);
				if (x % 2 == 1) { html.push(`${x / 2 + 0.5}`); }
				html.push('</TD>');
			}
			html.push('</TR>');
			html.push('</TABLE>');
			return advanced ? html.join('') : '';
		}

		function createCoordY(fs) {
			let html = [];
			html.push(`<TABLE border=0 cellSpacing=0 id="coordtabY" height="${tableWidth}px">`);
			for (let x = 0; x < FS * 2 + 1; x++) {
				html.push(`<TR><TD style="height:${x % 2 == 1 ? linesWidth : 0}px; font-size: ${tableWidth / (6.0 * FS)}; width: "${linesWidth}px" align="right" valign="middle">`);
				if (x % 2 == 1) { html.push(`${x / 2 + 0.5}`); }
				html.push('</TD></TR>');
			}
			html.push('</TABLE>');
			return advanced ? html.join('') : '';
		}

		function bounceTable() {
			const orig = document.getElementById('vartab');
			const container = orig.parentNode;

			if (document.getElementById('vartab-copy')) return;

			// Зберігаємо розміри до зміни позиціонування
			const origRect = orig.getBoundingClientRect();
			const width = orig.offsetWidth + 'px';
			const height = orig.offsetHeight + 'px';
			const left = orig.offsetLeft + 'px';
			const top = orig.offsetTop + 'px';

			// Зберігаємо старі стилі контейнера
			const prevMinWidth = container.style.minWidth;
			const prevMinHeight = container.style.minHeight;
			const prevWidth = container.style.width;
			const prevHeight = container.style.height;

			// Фіксуємо розмір контейнера на час анімації
			container.style.minWidth = width;
			container.style.minHeight = height;
			container.style.width = width;
			container.style.height = height;

			// Клонування таблиці
			const clone = orig.cloneNode(true);
			clone.id = 'vartab-copy';
			clone.style.position = 'absolute';
			clone.style.top = top;
			clone.style.left = left;
			clone.style.width = width;
			clone.style.height = height;
			clone.style.opacity = '1';
			clone.style.pointerEvents = 'none';
			clone.style.zIndex = '0';

			// Додаємо копію в контейнер
			container.insertBefore(clone, orig);

			// Робимо оригінал absolutely positioned для анімації
			orig.style.position = 'absolute';
			orig.style.zIndex = '1';
			orig.style.left = left;
			orig.style.top = (orig.offsetTop - orig.offsetHeight - 40) + 'px';
			orig.style.width = width;
			orig.style.height = height;
			orig.style.transition = 'top 0.7s cubic-bezier(.68,-0.55,.27,1.55)';

			setTimeout(() => {
				orig.style.top = top;
			}, 10);

			setTimeout(() => {
				orig.style.position = '';
				orig.style.zIndex = '';
				orig.style.left = '';
				orig.style.top = '';
				orig.style.width = '';
				orig.style.height = '';
				orig.style.transition = '';
				if (clone) clone.remove();

				// Повертаємо розміри контейнера назад ТІЛЬКИ якщо вони були задані!
				if (prevMinWidth) container.style.minWidth = prevMinWidth;
				if (prevMinHeight) container.style.minHeight = prevMinHeight;
				if (prevWidth) container.style.width = prevWidth;
				if (prevHeight) container.style.height = prevHeight;
				// Якщо були порожні — залишаємо фіксовані розміри!

				// Оновити таблицю!
				orig.style.width = tableWidth + 'px';
				orig.style.height = tableWidth + 'px';
			}, 2000);
		}

		function fnAdvanced() {
			advanced = (advanced == 0) ? 1 : 0;
			saveValue('advanced', advanced);
			writeHtml(0);
		}

	</script>

	<style>
		/* Скидання стилів для всієї сторінки */
		html,
		body {
			margin: 0;
			padding: 0;
			box-sizing: border-box;
			font-size: 16px;
			/* Базовий розмір шрифту */
			/*font-family: Arial, sans-serif;*/
			/* Ваш шрифт */
			/*background: #fff;*/
			/*background: #000;*/
		}

		/* Скидання для заголовків */
		h1,
		h2,
		h3,
		h4,
		h5,
		h6 {
			margin: 0;
			padding: 0;
			/*font-weight: normal;*/
		}

		/* Скидання для таблиць */
		table {
			border-collapse: collapse;
			margin: 0;
			padding: 0;
		}

		@keyframes bounce {
			0% {
				transform: translateY(-1000px);
			}

			20% {
				transform: translateY(-50px);
			}

			60% {
				transform: translateY(-10px);
			}

			70% {
				transform: translateY(-5px);
			}

			100% {
				transform: translateY(0);
			}
		}

		.bounce {
			animation: bounce 5s;
		}

		#textingCellL,
		#textingCell {
			min-width: 100px;
		}
	</style>
	<!-- Insert HTML here -->
	<h1 style="margin-bottom: 0em"><span style="color: #0000ff;">X</span><span style="color: #ffff00;">O</span><span
			style="font-weight: normal;">Game</span><span style="font-size: 10px;">36</span></h1>
	<table border=0 cellSpacing=0 cellPadding=0 id="maintable" width="100%">
		<tr>
			<td></td>
			<td id="column1">
				<div id="tc"></div><!-- X Container -->
			</td>
		</tr>
		<tr>
			<td valign="top">
				<div id="tv"></div><!-- Y Container -->
			</td>
			<td valign="top">
				<div id="tx-container" style="position: relative; min-height: 10px;">
					<div id="tx"></div><!-- Game Board Container -->
				</div>
			<td rowspan="3" align="left" valign="top">
				<div id="dyL"></div>
				<table border=0 cellSpacing=0 cellPadding=1>
					<tr>
						<td valign="top" id="column3L">
							<small>
								<div id="statL"></div>
							</small>
							<div id="ntL"></div>
						</td>
						<td valign="top" width="0px" id="textingCellL">
							<div id="textingL" style="max-width: 3000px;">
							</div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
				<div id="dy"></div>
			</td>
		</tr>
		<tr>
			<td colspan="3">
				<table border=0 cellSpacing=0 cellPadding=1 id="bottomTable">
					<tr>
						<td valign="top" id="column3">
							<small>
								<div id="stat"></div>
							</small>
							<div id="nt"></div>
						</td>
						<td valign="top" id="textingCell">
							<div id="texting"></div>
						</td>
					</tr>
				</table>
				<!--<div id="ex"></div>-->
				<!--<div id="displ"></div>-->
				<!--<div id="histo"></div>-->

			</td>
		</tr>
	</table>
	<!--<INPUT type="text" ID=redCell value="">-->
</BODY>

</HTML>