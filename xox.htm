<HTML>

<HEAD>
	<meta name=vs_targetSchema content="HTML 4.0">
	<meta name=vs_defaultClientScript content="JavaScript">
	<TITLE>XOGame</TITLE>
	<META NAME="GENERATOR" Content="Microsoft Visual Studio">
	<META HTTP-EQUIV="Content-Type" content="text/html">
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link rel="icon" type="image/png" href="xox.png">
</HEAD>

<BODY>
	<script language=javascript>

		let fieldSize = 7;// 7 - 9 - 11
		let FS = fieldSize;
		let gameLevel = 1; // 0 - hight level, 1 - easy, 2 - medium, 3 - hard
		let firstColorIndex = 0, secondColorIndex = 1, fieldMatrix = [], his = [];
		let greenVar = 0, grayCellId;//
		let newLevel = 0;
		let gameColorIndex = -1, roboSwitch = 0, gameOver = 0, changeSize = 0;
		let matrixCell = [];
		const lightGreenColor = "#f0fff0", darkGreenColor = "#808080";
		const pref = "v", idTab = "vartab", delayTime = 1500;
		const date = new Date();
		date.setFullYear(date.getFullYear() + 1); // +1 рік від поточної дати
		const expires = date.toUTCString();
		const width = window.innerWidth;
		let linesWidth = 20;
		let tableWidth = 1000;
		let orientation = (window.innerWidth > window.innerHeight) ? "landscape" : "portrait";
		let snake = 0;

		function cellId(n, x, y) {
			return n + String(y).padStart(2, '0') + String(x).padStart(2, '0');
		}

		function cellIdL(n, x, y) {
			return n + String(y).padStart(4, '0') + String(x).padStart(4, '0');
		}

		function index2Color(index) {
			switch (index) {
				case 0: return "#ffffff"; // white
				case 1: return "#000000"; // black
				case -1: return "#0000ff"; // blue
				case -2: return "#ffff00"; // yellow
				case 2: return "#e0e0e0"; // gray
				default: return "#ffffff";
			}
		}

		function delay(ms) { return new Promise(resolve => setTimeout(resolve, ms)); }

		function getCookie(name) {
			const value = `; ${document.cookie}`;
			const parts = value.split(`; ${name}=`);
			if (parts.length === 2) return parts.pop().split(';').shift();
		}

		function printCookie() {
			document.getElementById("displ").innerHTML = document.cookie;
		}

		function deleteCookie() {
			localStorage.clear();
		}

		function resetGame() {
			//localStorage.removeItem('fieldMatrix');
			//localStorage.removeItem('his');
			//localStorage.removeItem('roboSwitch');
			if (confirm('Are you sure you want to completely reset the game??')) {
				localStorage.clear();
				location.reload();
			}
		}

		//Bill function to count the number of lines
		function bill(fieldSize) {
			let a = 0, b = 0;
			for (let j = 0; j < fieldSize; j++) {
				for (let k = 0; k < fieldSize; k++) {
					const val = fieldMatrix[j * 2 + 1][k * 2 + 1];
					if (!((j * 2 + 1) === 1 && (k * 2 + 1) === 1)) {
						if (val === firstColorIndex) a++;// blue
						if (val === secondColorIndex) b++;// yellow
					}
				}
			}
			displOne(a, b);
			displText(a, b);
			if (a + b < fieldSize * fieldSize - ((fieldSize - 1) / 2) * (((fieldSize - 1) / 2) - 1) * 2) {
				writeMatrix();
			} else {
				localStorage.removeItem('fieldMatrix');
			}

		}

		function displText(a, b) {
			const fs = fieldSize;
			const lon = fs * fs - ((fs - 1) / 2) * (((fs - 1) / 2) - 1) * 2;
			let symbolClear = "&#9633"; // clear square
			symbol = "&#9632"// bflack square
			let dyId = orientation === "landscape" ? "dyL" : "dy";
			document.getElementById(dyId).innerHTML = `<table border=0 cellSpacing=0 cellPadding=0>
						<tr>
							<td style="width: ${tableWidth}px; font-size: ${tableWidth * 2.46 / ((fieldSize + 1) * (fieldSize + 1))}; word-break: break-all;"><span style="color: ${index2Color(firstColorIndex)}">${symbol.repeat(a)}</span><span>${symbolClear.repeat(lon - a - b)}</span><span style="color: ${index2Color(secondColorIndex)}">${symbol.repeat(b)}</span></td>
						</tr>
						<tr>
							<td style="width: ${tableWidth}px; font-size: ${tableWidth * 2.46 / ((fieldSize + 1) * (fieldSize + 1))}; word-break: break-all;"><span style="color: ${index2Color(secondColorIndex)}">${symbol.repeat(b)}</span><span>${symbolClear.repeat(lon - a - b)}</span><span style="color: ${index2Color(firstColorIndex)}">${symbol.repeat(a)}</span></td>
						</tr>
					</table>`;
		}

		function displOne(a, b) {
			const fs = fieldSize;
			const lon = fs * fs - ((fs - 1) / 2) * (((fs - 1) / 2) - 1) * 2;

			// Формування рядка поточної партії
			let dif = a - b, col = firstColorIndex, f = 0;
			if (dif < 0) {
				dif = -dif;
				col = secondColorIndex;
				f = 1;
			}
			if (firstColorIndex == -2) {
				f = (f === 0) ? 1 : 0;
			}
			let allVal = 0;
			let currentRow = "";
			if (a + b == lon) {
				gameOver = 1;
				his.push([fieldSize, gameLevel, a, b]);
				saveHis();
				localStorage.removeItem('roboSwitch');
			} else {
				currentRow = `<tr>
					<td align = center>${fs}</td>
					<td bgcolor=${index2Color(col)} align = center><font color="${index2Color(f)}">${gameLevel}</font></td>
					<td align = center>${a}</td>
					<td align = center bgcolor=${index2Color(col)}><font color="${index2Color(f)}">${dif}</font></td>
					<td align = center>${b}</td>
				</tr>`;
				allVal = a - b;
			}

			// Формування історії
			let hisRev = his.slice().reverse();
			let g;
			g = (f === 0) ? 1 : 0;
			f = (firstColorIndex === -2) ? 1 : 0;
			g = (secondColorIndex === -2) ? 1 : 0;
			let txt = `<table border=0>
        		<tr bgcolor="${index2Color(firstColorIndex)}"><td></td><td></td><td></td><td></td><td></td><td></td></tr>
        		<tr>
					<th style="font-size: ${gameLevel * 100}%; color: ${index2Color(firstColorIndex)}"rowspan="${his.length * 2 + 3}" valign = "top">${gameLevel}</th>
            		<th id="size">Size</th>
            		<th id="level">Level</th>
            		<th bgcolor="${index2Color(firstColorIndex)}"><font color="${index2Color(f)}">${lon}</font></th>
           			<th id="all"></th>
            		<th bgcolor="${index2Color(secondColorIndex)}" align="center">
						<font color="${index2Color(g)}">${fs > 7 ? (fs - 2) * (fs - 2) - (((fs - 2) - 1) / 2) * ((((fs - 2) - 1) / 2) - 1) * 2 : 0}</font>
					</th>
        		</tr>
        		<tr bgcolor="${index2Color(2)}"><td></td><td></td><td></td><td></td><td></td></tr>
        		${currentRow}
    		`;

			for (const i of hisRev) {
				let diff = i[2] - i[3], col = firstColorIndex, f = 0;
				allVal += diff;
				if (diff < 0) {
					diff = -diff;
					col = -2;
					f = 1;
				}
				if (firstColorIndex == -2) {
					f = (f === 0) ? 1 : 0;
				}
				txt += `<tr bgcolor="${index2Color(2)}"><td></td><td></td><td></td><td></td><td></td></tr>
        		<tr>
            		<td align="center">${i[0]}</td>
            		<td bgcolor="${index2Color(col)}" align="center"><font color="${index2Color(f)}">${i[1]}</font></td>
            		<td align="center">${i[2]}</td>
            		<td bgcolor="${index2Color(col)}" align="center"><font color="${index2Color(f)}">${diff}</font></td>
            		<td align="center">${i[3]}</td>
        		</tr>`;
			}
			txt += `<tr bgcolor="${index2Color(2)}"><td></td><td></td><td></td><td></td><td></td><td></td></tr></table>`;
			let ntId = orientation === "landscape" ? "ntL" : "nt";
			document.getElementById(ntId).innerHTML = txt;

			// Відображення загального рахунку
			let allValModule = Math.abs(allVal);
			col = allVal < 0 ? secondColorIndex : firstColorIndex;
			let fontK = 1;

			// Автоматична зміна рівня/розміру
			let m = 0;
			if (fs > 7) m = (fs - 2) * (fs - 2) - (((fs - 2) - 1) / 2) * ((((fs - 2) - 1) / 2) - 1) * 2;
			newLevel = 0;
			if (fs > 7 && allVal < m) {
				newLevel = (gameLevel > 1) ? -1 : 0;
				//newLevel = -1;
				document.getElementById("level").bgColor = index2Color(secondColorIndex);
				document.getElementById("size").bgColor = index2Color(secondColorIndex);
				f = (secondColorIndex === -2) ? 1 : 0;
				document.getElementById("level").innerHTML = `<font color="${index2Color(f)}">${document.getElementById("level").innerText}</font>`;
				document.getElementById("size").innerHTML = `<font color="${index2Color(f)}">${document.getElementById("size").innerText}</font>`;
				fontK = 0.5;
			} else
				if (allVal > lon) {
					newLevel = (gameLevel > 0) ? 1 : 0;
					document.getElementById("level").bgColor = index2Color(firstColorIndex);
					document.getElementById("size").bgColor = index2Color(firstColorIndex);
					g = (firstColorIndex === -2) ? 1 : 0;
					document.getElementById("level").innerHTML = `<font color="${index2Color(g)}">${document.getElementById("level").innerText}</font>`;
					document.getElementById("size").innerHTML = `<font color="${index2Color(g)}">${document.getElementById("size").innerText}</font>`;
					fontK = 3;
				}

			// Оновлення відображення all
			f = (col == -1) ? 0 : 1;
			const cell = document.getElementById("all");
			cell.innerHTML = `<font color="${index2Color(f)}">${allValModule}</font>`;
			cell.bgColor = index2Color(col);
			cell.style.fontSize = `${fontK * 100}%`;
			changeSize = 0;

		}

		// Robot function to find and click on lines
		function robot(query) {
			const fs = fieldSize;
			firstColorSet();
			// 1. Вибір матриці для аналізу
			let matrix = (query <= 0)
				? (gameColorIndex !== firstColorIndex
					? fieldMatrix.map(row => row.map(val => val === 1 ? 1 : 0))
					: fieldMatrix.map(row => row.slice()))
				: (gameColorIndex == firstColorIndex
					? fieldMatrix.map(row => row.map(val => val === 1 ? 1 : 0))
					: fieldMatrix.map(row => row.slice()));

			// 3. Пошук можливих ліній
			let mxlnv = [], mxlnh = [];
			for (let y = 1; y <= fs; y++) {
				for (let x = 1; x < fs; x++) {
					let xx = 2 * x, yy = 2 * y - 1, z = 0;
					if (
						matrix[yy][xx - 1] === 0 && matrix[yy][xx + 1] === 0 &&
						matrix[yy - 1][xx] === 1 && matrix[yy + 1][xx] === 1 &&
						matrix[yy][xx] === 0
					) {
						mxlnv.push([yy, xx, z]);
					}
				}
			}
			for (let y = 1; y < fs; y++) {
				for (let x = 1; x <= fs; x++) {
					let xx = 2 * x - 1, yy = 2 * y, z = 0;
					if (
						matrix[yy - 1][xx] === 0 && matrix[yy + 1][xx] === 0 &&
						matrix[yy][xx - 1] === 1 && matrix[yy][xx + 1] === 1 &&
						matrix[yy][xx] === 0
					) {
						mxlnh.push([yy, xx, z]);
					}
				}
			}

			// Оцінка ходів (rate)
			const mxln = [...mxlnh, ...mxlnv];// Combine horizontal and vertical lines
			for (const ln of mxlnv) {
				let mxCopy = matrix.map(row => row.slice());
				mxCopy[ln[0]][ln[1]] = 1;
				sqare(mxCopy, ln, ln[0], ln[1] - 1); // left square
				sqare(mxCopy, ln, ln[0], ln[1] + 1); // right square
			}
			for (const ln of mxlnh) {
				let mxCopy = matrix.map(row => row.slice());
				mxCopy[ln[0]][ln[1]] = 1;
				sqare(mxCopy, ln, ln[0] - 1, ln[1]); // top square
				sqare(mxCopy, ln, ln[0] + 1, ln[1]); // bottom square
			}

			// 5. Вибір ходу з мінімальним rate
			if (mxln.length > 0) {
				const ratemin = Math.min(...mxln.map(a => a[2]));// Find minimum rate
				const filtered = (ratemin <= gameLevel * gameLevel || gameLevel === 0 || query === 1)// Filter lines based on game level**2
					? mxln.filter(a => a[2] <= ratemin)
					: mxln;
				const min = 0, max = filtered.length - 1;// Random selection from filtered lines
				const randomInt = Math.floor(Math.random() * (max - min + 1)) + min;// Random index

				// 6. Виконання дії залежно від query
				if (query == 0) {
					clickk(cellId(pref, filtered[randomInt][1] + FS - fs, filtered[randomInt][0] + FS - fs));// click on random line
					robot(10);
				} else if (query == 1) {
					fnBlick(filtered[randomInt][0] + FS - fs, filtered[randomInt][1] + FS - fs);
				} else if (query == 2) {
					if (ratemin == 0 && filtered.length > 5) {
						clickk(cellId(pref, filtered[randomInt][1] + FS - fs, filtered[randomInt][0] + FS - fs));// click on random line
						fnAutoBlick(query);
					}
				} else if (query == -2) {
					clickk(cellId(pref, filtered[randomInt][1] + FS - fs, filtered[randomInt][0] + FS - fs));// click on random line
					fnAutoBlick(query);
				} else if (query == 10) {
					fnReNew(filtered[randomInt][0] + FS - fs, filtered[randomInt][1] + FS - fs);
				}
				if ((query == 2 || query == -2) && ratemin == 0 && filtered.length <= 6) {
					roboSwitch = 0;
					roboColor('vartab');
				}
				if (query == -1) {
					fnBlick(filtered[randomInt][0] + FS - fs, filtered[randomInt][1] + FS - fs);
				}
				if (query == 10) {
					fnStatus(ratemin, filtered.length);
				}
			}
			if (query != 10) {
				robot(10);
			}
		}

		// Status function to display the rate and number of available lines
		function fnStatus(rateMin, filteredLength) {
			let symbol = "&#9632"; // black square
			let statId = orientation === "landscape" ? "statL" : "stat";
			let rateCount = rateMin;
			if (rateMin == 0) { symbol = "&#9633"; rateCount = 1; }// white square
			if (rateCount <= 20) {
				document.getElementById(statId).innerHTML = `${symbol.repeat(rateCount)} : ${filteredLength}`;
			} else {
				document.getElementById(statId).innerHTML = ``;
			}
		}

		async function fnAutoBlick(query) {
			await delay(100);
			robot(-query);
		}

		async function fnBlick(y, x) {
			document.getElementById(cellId(pref, x, y)).bgColor = "#00ff00";// green
			await delay(1000);
			document.getElementById(cellId(pref, x, y)).bgColor = index2Color(2);// gray
		}

		async function fnReNew(y, x) {
			await delay(100);
		}

		// Function to handle cell clicks
		function lnCheckV(mx, ln, y, x) {
			sqare(mx, ln, y, x - 1); // left square
			sqare(mx, ln, y, x + 1); // right square
		}

		// Function to check if a square can be formed and update the matrix and line count
		function lnCheckH(mx, ln, y, x) {
			sqare(mx, ln, y - 1, x); // top square
			sqare(mx, ln, y + 1, x); // bottom square
		}

		// Function to check if a square can be formed and update the matrix and line count
		function sqare(mx, ln, ysq, xsq) {
			if (
				ysq > 0 && xsq > 0 &&
				ysq < mx.length - 1 && xsq < mx[0].length - 1
			) {
				const sum =
					Number(mx[ysq - 1][xsq]) +
					Number(mx[ysq + 1][xsq]) +
					Number(mx[ysq][xsq - 1]) +
					Number(mx[ysq][xsq + 1]);
				if (sum === 3) {
					ln[2]++;
					if (Number(mx[ysq - 1][xsq]) === 0) {
						mx[ysq - 1][xsq] = 1;
						lnCheckH(mx, ln, ysq - 1, xsq);
					}
					if (Number(mx[ysq + 1][xsq]) === 0) {
						mx[ysq + 1][xsq] = 1;
						lnCheckH(mx, ln, ysq + 1, xsq);
					}
					if (Number(mx[ysq][xsq - 1]) === 0) {
						mx[ysq][xsq - 1] = 1;
						lnCheckV(mx, ln, ysq, xsq - 1);
					}
					if (Number(mx[ysq][xsq + 1]) === 0) {
						mx[ysq][xsq + 1] = 1;
						lnCheckV(mx, ln, ysq, xsq + 1);
					}
				}
			}
		}

		//
		function roboColor(idTab) {
			roboSwitch = roboSwitch === 0 ? 1 : 0;
			document.getElementById(cellId(pref, 2 * FS - 1, 2 * FS - 1)).bgColor =
				roboSwitch === 1 ? index2Color(2) : index2Color(0);
			saveValue('roboSwitch', roboSwitch);
			writeText();
			document.getElementById("grayBtn").value = gameLevel;
			document.getElementById("grayBtn").style.backgroundColor =
				roboSwitch === 1 ? index2Color(2) : index2Color(0);
		}

		// 
		async function autoSet(idTab, fieldSize) {
			for (let j = 0; j < fieldSize; j++) {
				for (let k = 0; k < fieldSize; k++) {
					const y = j * 2 + 1, x = k * 2 + 1;
					const arrCol = AroMatrix(y, x).map(a => Number(a == 1));
					const sum = arrCol.reduce((a, b) => a + b, 0);
					if (sum === 3) {
						let cId = null;
						for (const [yy, xx, value] of AroMatrixYXC(y, x)) {
							if (value !== 1) {
								cId = cellId(pref, xx + FS - fieldSize, yy + FS - fieldSize);
								break;
							}
						}
						if (cId) {
							await delay(100);
							if (gameOver == 0) {
								await clickk(cId);
								await autoSet(idTab, fieldSize);
							}
							return;
						}
					}
				}
			}
			await delay(800);
			if (roboSwitch === 1) await robot(0);
			if (gameOver == 0) {
				bill(fieldSize);
			}
		}

		// Function to get the neighbors of a cell in the matrix
		function AroMatrix(y, x) {
			return [
				fieldMatrix[y - 1]?.[x] === 1,
				fieldMatrix[y + 1]?.[x] === 1,
				fieldMatrix[y]?.[x - 1] === 1,
				fieldMatrix[y]?.[x + 1] === 1
			];
		}

		// Function to get the neighbors of a cell in the matrix
		function AroMatrixYXC(y, x) {
			return [
				[y - 1, x, fieldMatrix[y - 1]?.[x]],
				[y + 1, x, fieldMatrix[y + 1]?.[x]],
				[y, x - 1, fieldMatrix[y]?.[x - 1]],
				[y, x + 1, fieldMatrix[y]?.[x + 1]]
			];
		}

		// 
		function lightGreen() {
			for (let y = 1; y < fieldSize * 2; y += 2) {
				for (let x = 1; x < fieldSize * 2; x += 2) {
					if (
						fieldMatrix[y][x] === 0 &&
						x + y > fieldSize - 2 &&
						x + y < 3 * fieldSize + 2 &&
						-x + y < fieldSize + 2 &&
						x - y < fieldSize + 2
					) {
						document.getElementById(cellId(pref, x + FS - fieldSize, y + FS - fieldSize)).bgColor =
							greenVar === 1 ? lightGreenColor : index2Color(0);// white or light green
					}
				}
			}
		}

		// 
		function darkGreen() {
			for (let y = 0; y < fieldSize * 2 + 1; y += 1) {
				for (let x = 0; x < fieldSize * 2 + 1; x += 1) {
					if (
						fieldMatrix[y][x] === 1
					) {
						document.getElementById(cellId(pref, x + FS - fieldSize, y + FS - fieldSize)).bgColor =
							greenVar === 1 ? darkGreenColor : index2Color(1);// black or dark green
					}
				}
			}
		}

		// Function to pause the game
		async function gamePause() {
			greenVar = 1;
			lightGreen();
			darkGreen();
			await delay(delayTime);
			greenVar = 0;
			lightGreen();
			darkGreen();
		}

		function firstColorSet() {
			firstColorIndex = Number(getValue('firstColorIndex', firstColorIndex));
			secondColorIndex = Number(getValue('secondColorIndex', secondColorIndex));
			if (firstColorIndex === 0) {
				firstColorIndex = gameColorIndex;
				secondColorIndex = (firstColorIndex === -1) ? -2 : -1;
			}
			saveValue('firstColorIndex', firstColorIndex);
			saveValue('secondColorIndex', secondColorIndex);
		}

		// Function to handle clicks on the game board
		async function clickh(nam) {
			let y = parseInt(nam.substr(1, 2), 10);
			let x = parseInt(nam.substr(3, 2), 10);
			let X = x - FS + fieldSize;
			let Y = y - FS + fieldSize;
			if (fieldMatrix[Y][X] == 2) {
				if (greenVar === 0 && gameOver === 0) {
					await clickk(nam);
					//document.cookie = `fieldMatrix=${JSON.stringify(fieldMatrix)}; expires=${expires}; path=/`;
					if (roboSwitch === 1) gamePause();
				}
				changeSize = 1;
			}
		}
		// Function to handle clicks on the game board 
		function clickk(nam) {
			const fs = fieldSize;
			const Bor = document.getElementById(nam);
			const ny = Number(nam.substr(1, 2));
			const nx = Number(nam.substr(3, 2));
			const nX = nx - FS + fieldSize;
			const nY = ny - FS + fieldSize;

			if (fieldMatrix[nY][nX] === 2) {
				fieldMatrix[nY][nX] = 1;
				Bor.bgColor = index2Color(1);

				firstColorSet();
				// ������� ����� ����� � ����� ��������� (rate)
				const arrMatrix = nY % 2 === 1
					? [[nY, nX - 1, 0], [nY, nX + 1, 0]]
					: [[nY - 1, nX, 0], [nY + 1, nX, 0]];
				// ���������� ����� �� ������������
				let refill = 0;// ��������� ��� ��������������
				for (const ln of arrMatrix) {// ln[0] - y, ln[1] - x
					const y = ln[0], x = ln[1];// ���������� �����
					const sum = AroMatrix(y, x).reduce((a, b) => a + Number(b), 0);// ���� �����
					if (sum == 4) {// ���� �� ����� ���������
						fieldMatrix[y][x] = gameColorIndex;// ���������� �����
						refill = 1;// ��������� ��� ��������������
						document.getElementById(cellId(pref, x + FS - fieldSize, y + FS - fieldSize)).bgColor = index2Color(gameColorIndex);// ������� ���� �����
					}
				}
				// ����������, �� ������� ��������� �����
				autoSet(idTab, fs);
				if (refill === 0) { colsel(pref + "0101"); }
			}
			bill(fs);
		}

		// Function to toggle the color selection
		function colsel(id) {
			firstColorIndex = Number(getValue('firstColorIndex', firstColorIndex));
			secondColorIndex = Number(getValue('secondColorIndex', secondColorIndex));
			if (firstColorIndex === 0) {
				secondColorIndex = gameColorIndex;
				firstColorIndex = (secondColorIndex === -1) ? -2 : -1;
			}
			gameColorIndex = (gameColorIndex === firstColorIndex) ? secondColorIndex : firstColorIndex; // toggle between blue and yellow
			document.getElementById(id).bgColor = index2Color(gameColorIndex);
			let f;
			if (gameColorIndex == -1) {
				f = 0;
			} else {
				f = 1;
			}
			document.getElementById(id).innerHTML = `<font color=${index2Color(f)}>${document.getElementById(id).innerText}</font>`;
			saveValue('firstColorIndex', firstColorIndex);
			saveValue('secondColorIndex', secondColorIndex);
		}

		function hasCookie(name) {
			return document.cookie.split(';').some((item) => item.trim().startsWith(name + '='));
		}

		function saveValue(name, value) {
			localStorage.setItem(name, value);
		}

		function getValue(name, defaultValue) {
			const value = localStorage.getItem(name);
			return value !== null ? value : defaultValue;
		}

		function writeMatrix() {
			// Зберегти матрицю
			localStorage.setItem('fieldMatrix', JSON.stringify(fieldMatrix));
		}

		function readMatrix() {
			// Отримати матрицю
			fieldMatrix = JSON.parse(localStorage.getItem('fieldMatrix') || '[]');
		}

		function saveHis() {
			localStorage.setItem('his', JSON.stringify(his));
		}

		function getHis() {
			// Отримати матрицю
			his = JSON.parse(localStorage.getItem('his') || JSON.stringify(his));
		}

		// Function to create the HTML structure for the game board
		function createHtml(fs, FS, change) {
			let html = [];
			let cellWidth;
			let cellHeight;
			fieldMatrix = Array.from({ length: FS * 2 + 2 }, () => Array(FS * 2 + 1).fill(0));
			if (change == 0 && localStorage.getItem('fieldMatrix') !== null) {
				readMatrix();
			}
			let dF = FS - fs
			html.push(`<TABLE border=0 cellSpacing=0 id="vartab" style="table-layout: fixed; border-collapse: collapse; width: ${tableWidth}px; height: ${tableWidth}px;">`);
			for (let y = 0; y < FS * 2 + 1; y++) {
				html.push(`<TR style="height:${y % 2 == 1 ? linesWidth : linesWidth / 10}px;">`);
				for (let x = 0; x < FS * 2 + 1; x++) {
					X = x - dF; Y = y - dF;
					let td = `<TD id="${cellId(pref, x, y)}" bgcolor="`;
					let ck = 0;
					// Визначаємо колір клітинки
					if (x == 2 * FS - 1 && y == 2 * FS - 1) { td += index2Color(roboSwitch === 1 ? 2 : 0); } //gray or white
					else if (x == 1 && y == 1) { td += index2Color(-1); } // blue
					else if (x % 2 == 1 && y % 2 == 1) { td += index2Color(x >= dF && y >= dF && x <= 2 * FS - dF && y <= 2 * FS - dF ? fieldMatrix[Y < 0 || Y > 2 * fs ? 0 : Y][X < 0 || X > 2 * fs ? 0 : X] : 0); } // white square
					else if ((x % 2 == 0 && y % 2 == 0
						&& X + Y >= fs - 3 && X + Y <= (3 * fs) + 3
						&& ((-X + Y) <= (fs + 3)) && ((X - Y) <= (fs + 3))
						&& Y >= 0 && X >= 0 && Y <= fs * 2 && X <= fs * 2
					) || (x >= dF && y >= dF
						&& x <= 2 * FS - dF && y <= 2 * FS - dF
						&& (fieldMatrix[Y < 0 || Y > 2 * fs ? 0 : Y][X < 0 || X > 2 * fs ? 0 : X] === 1))
					) { td += index2Color(1); ck = 2; } // black lines & dots
					else if ((false
						|| (X + Y == fs - 2) || (-X + Y == fs + 2)
						|| (X - Y == fs + 2) || (X + Y == (3 * fs + 2))
						|| (X == fs && Y == 0) || (X == fs && Y == 2 * fs)
						|| (X == 0 && Y == fs) || (X == 2 * fs && Y == fs)
					) && Y >= 0 && X >= 0 && Y <= fs * 2 && X <= fs * 2) { td += index2Color(1); }// black perimeter 
					else { td += index2Color(2); ck = 1; }// gray # area
					td += '"';
					cellWidth = (x % 2 == 1 ? linesWidth : linesWidth / 10);
					cellHeight = (y % 2 == 1 ? linesWidth : linesWidth / 10);
					td += ` style="width:${cellWidth}px; height:${cellHeight}px; max-height:${cellHeight}px; min-height:${cellHeight}px; padding:0px; margin:0px; border:0px; font-size:${tableWidth / (1.5 * FS)}px; line-height:${cellHeight}px; overflow:hidden; vertical-align:middle; white-space: nowrap;"`;
					td += ' onclick="';
					// Призначаємо події
					if (x == 1 && y == 1) { td += "colsel('" + pref + "0101')"; } // blue
					else if (x == 3 && y == 1) { td += "fnChanger(2)"; }//+
					else if (x == 1 && y == 3) { td += "fnChanger(-2)"; }//-
					else if (x == FS * 2 - 1 && y == FS * 2 - 3) { td += "fnLevel(1)"; } //+
					else if (x == FS * 2 - 3 && y == FS * 2 - 1) { td += "fnLevel(-1)"; } //-
					else if (x == 3 && y == FS * 2 - 1) { td += "fnNewGame()"; } //#
					else if (x == 1 && y == FS * 2 - 1) { td += "fnAuto()"; } //>
					else if ((X + Y === fs - 3 || X + Y == 3 * fs + 3 || -X + Y == fs + 3 || X - Y == fs + 3) && Y >= 0 && X >= 0 && Y <= fs * 2 && X <= fs * 2 && x % 2 == 1 && y % 2 == 1) { td += "fnQuery()"; }
					else if (x == (2 * FS - 1) && y == 1) { td += "robot(0)"; }
					else if (x == 2 * FS - 1 && y == 2 * FS - 1) { td += "roboColor('vartab')"; }
					else if (ck == 1 && X + Y > fs - 4 && X + Y < 3 * fs + 4 && -X + Y < fs + 4 && X - Y < fs + 4) { td += "clickh('" + cellId(pref, x, y) + "')"; }
					else if (ck != 2 && X + Y > fs - 4 && X + Y < 3 * fs + 4 && -X + Y < fs + 4 && X - Y < fs + 4) { matrixCell.push(cellId(pref, x, y)); }
					else if (x == FS * 2 - 3 && y == 1) { td += "fnWorm()"; } //W
					else if (x == FS * 2 - 1 && y == 3) { td += "fnSnake()"; } //S
					else if (x == 1 && y == FS * 2 - 3 && FS > 7) { td += "resetGame()"; }//R
					td += '"';
					td += ' align="center" valign="middle">';
					// Символи
					if ((x == 1 && y == 1)) { td += `<font color=${index2Color(0)}>${fs}</font>`; }
					else if (x == 3 && y == 1) { td += "+"; }
					else if (x == 1 && y == 3) { td += "-"; }
					else if (x == FS * 2 - 1 && y == FS * 2 - 3) { td += "+"; }
					else if (x == FS * 2 - 3 && y == FS * 2 - 1) { td += "-"; }
					else if (x == 1 && y == FS * 2 - 1) { td += '>' }
					else if (x == 3 && y == FS * 2 - 1) { td += '#' }
					else if ((X + Y === fs - 3 || X + Y == 3 * fs + 3 || -X + Y == fs + 3 || X - Y == fs + 3) && Y >= 0 && X >= 0 && Y <= fs * 2 && X <= fs * 2 && x % 2 == 1 && y % 2 == 1) { td += '?' }
					else if (x == FS * 2 - 3 && y == 1) { td += 'W'; }
					else if (x == FS * 2 - 1 && y == 3) { td += 'S'; }
					else if (x == FS * 2 - 1 && y == FS * 2 - 1) { td += gameLevel; }
					else if (x == 1 && y == FS * 2 - 3 && FS > 7) { td += 'R' }
					td += '</TD>';
					html.push(td);
				}
				html.push('</TR>');
			}
			html.push('</TABLE>');
			return html.join('');
		}

		// Initial call to set up the game board
		function writeHtml(change) {
			tableWidth = Math.min(window.innerWidth, window.innerHeight) * 0.95;
			FS = Number(getValue("FS", 7));
			roboSwitch = Number(getValue("roboSwitch", roboSwitch));
			fieldSize = Number(getValue("fieldSize", 7));
			const fs = fieldSize;
			gameLevel = Number(getValue('level', gameLevel));
			getHis();
			matrixCell = []; // Очищення
			document.getElementById("column1").style.width = `${24 * FS + 20}px`;

			// Оновлення ігрового поля
			document.getElementById("tc").innerHTML = createCoordX(fs);
			document.getElementById("tv").innerHTML = createCoordY(fs);
			document.getElementById("tx").innerHTML = createHtml(fs, FS, change);

			displText(0, 0);
			grayCellId = cellId(pref, FS * 2 - 1, FS * 2 - 1);

			// Створення fieldMatrix нового розміру
			fieldMatrix = Array.from({ length: 2 * fs + 1 }, (_, y) =>
				Array.from({ length: 2 * fs + 1 }, (_, x) => {
					const col = document.getElementById(cellId(pref, x + FS - fieldSize, y + FS - fieldSize)).bgColor;
					return col === index2Color(1) ? 1 : col === index2Color(2) ? 2 : col === index2Color(-1) ? -1 : col === index2Color(-2) ? -2 : 0;
				})
			);

			// Делегування подій для кліків (опціонально)
			//document.getElementById("vartab").onclick = function (e) {
			//	if (e.target.tagName === "TD") handleCellClick(e.target);
			//};

			// Додаємо обробники кліків для кожної клітинки
			matrixCell.forEach(id => {
				const cell = document.getElementById(id);
				// Замість addEventListener можна використовувати onclick, щоб не накопичувати події:
				cell.onclick = function (e) {
					const rect = this.getBoundingClientRect();
					const x = e.clientX - rect.left;
					const y = e.clientY - rect.top;
					const w = rect.width, h = rect.height;

					// Діагоналі: y = x (головна), y = h - x (побічна)
					if (y < x && y < h - x) { clickh(getNeighborCellId(id, -1, 0)); } // up
					else if (y < x && y >= h - x) { clickh(getNeighborCellId(id, 0, 1)); } // right
					else if (y >= x && y < h - x) { clickh(getNeighborCellId(id, 0, -1)); } // left
					else if (y >= x && y >= h - x) { clickh(getNeighborCellId(id, 1, 0)); }// down
				};
			});
			if (his.length > 0) { firstColorSet(); }
			robot(0);
			bill(fs);
			writeText()
			document.getElementById("grayBtn").value = gameLevel;
		}

		function writeText() {
			let symbol = "&#9632"; // black square
			let textingId;
			textingId = orientation == "landscape" ? "textingL" : "texting";
			document.getElementById(textingId).innerHTML = `<span style="color: ${index2Color(firstColorIndex)}">&#9632</span> is ${roboSwitch == 1 ? 'your' : 'first gamer'} color`;
			document.getElementById(textingId).innerHTML += `<br><span style="color: ${index2Color(secondColorIndex)}">&#9632</span> is ${roboSwitch == 1 ? 'robot' : 'second gamer'} color`;
			document.getElementById(textingId).innerHTML += `<br><span style="color: ${index2Color(firstColorIndex)}; font-weight: bold;">${gameLevel}</span> is game level`;
			document.getElementById(textingId).innerHTML += '<br>Try pressing <input type="button" value=">" onclick="fnAuto()" id="autoBtn1" style="width: 30px; height: 30px; font-size: 24px;"> to get started. The first moves will be automatic.';
			document.getElementById(textingId).innerHTML += '<br>The goal is to get more squares of your color to move to a higher level and board size.';
			document.getElementById(textingId).innerHTML += `<hr>Click on the gray square <input type="button" value="1" onclick="roboColor('vartab')" id="grayBtn" style="width: 30px; height: 30px; font-size: 24px;background-color:#eee; border:none;"> to toggle the robot on/off.`;
			document.getElementById(textingId).innerHTML += `<br>White square <input type="button" value=" " onclick="robot(0)" id="whiteBtn" style="width: 30px; height: 30px; font-size: 24px; background-color:#fff;"> in the upper right corner - robot progress.`;
			document.getElementById(textingId).innerHTML += `<br><input type="button" value="?" onclick="fnQuery()" id="hintBtn" style="width: 30px; height: 30px; font-size: 24px;"> - hint<br>`;
			document.getElementById(textingId).innerHTML += `<br><input type="button" value="R" onclick="resetGame()" id="rBtn" style="width: 30px; height: 30px; font-size: 24px;"> - Full reset of the entire game<br>`;
		}
		// Function to create the display area for the game
		function createDisplOne(fs) {
			const dimen = fs * fs - ((fs - 1) / 2) * (((fs - 1) / 2) - 1) * 2;
			const html = [];
			html.push(`<TABLE WIDTH="${24.3 * FS}" HEIGHT="12" BORDER="0" CELLSPACING="1" CELLPADDING="1" bgcolor="#ffffff" id="displt">`);
			html.push('<TR>');
			for (let i = 0; i < dimen; i++) {
				html.push(`<TD id="${cellIdL("e", i, 0)}" bgcolor="${index2Color(2)}"></TD>`);
			}
			html.push('<TR>');
			html.push('</TR>');
			for (let i = 0; i < dimen; i++) {
				html.push(`<TD id="${cellIdL("f", i, 0)}" bgcolor="${index2Color(2)}"></TD>`);
			}
			html.push('</TR></TABLE>');
			return html.join('');
		}

		// Event listener to call writeHtml when the document is loaded
		document.addEventListener('DOMContentLoaded', function () { writeHtml(0); });

		// Helper function to generate cell IDs
		function getNeighborCellId(cellId, dy, dx) {
			let y = parseInt(cellId.substr(1, 2), 10);
			let x = parseInt(cellId.substr(3, 2), 10);
			let Y = y - FS + fieldSize;
			let X = x - FS + fieldSize;
			if (fieldMatrix[Y + dy][X + dx] === 1) {
				if (fieldMatrix[Y - dy][X - dx] === 1) {
					[dx, dy] = [dy, dx];// swap
				} else if (fieldMatrix[Y + dy][X - dx] === 1) {
					dy = -dy;
				} else if (fieldMatrix[Y - dy][X + dx] === 1) {
					dx = -dx;
				}
			}
			let newY = (y + dy).toString().padStart(2, '0');
			let newX = (x + dx).toString().padStart(2, '0');
			return pref + newY + newX;
		}

		function changeLevel() { gameLevel = Number(document.getElementById("flevel").value); }

		let x = 0, y = 0, colorX = [], coord = [], i = 0, dx = 0, dy = 0, wLength = 7, wormColor = "#0033ff";

		async function fnWorm() {
			colorX[i] = document.getElementById(cellId(pref, x + 0, y + 0)).bgColor;
			coord[i] = cellId(pref, x, y);
			document.getElementById(coord[i]).bgColor = document.getElementById("v0101").bgColor;
			if (i > wLength + 1) { document.getElementById(coord[i - 2 - wLength]).bgColor = colorX[i - 2 - wLength]; }
			if (x < fieldSize * 2 && y == 0) {
				dx = 1; dy = 0;
			} else if (y < fieldSize * 2 && x == fieldSize * 2) {
				dx = 0; dy = 1;
			} else if (y == fieldSize * 2 && x > 0) {
				dx = -1; dy = 0;
			} else { dx = 0; dy = -1; }
			x = x + dx; y = y + dy; i++;
			if (i % 2 == 0) { await delay(400); }
			fnWorm();
		}

		let cYX = [], xs = 1, ys = 1, is = 0;

		let snakeMatrix = [], N;

		async function fnSnake() {
			N = 7;
			snake = (snake == 0) ? 1 : 0;
			fnSnakeII(0, 1);
		}

		async function fnSnakeII(deltaYold, deltaXold) {
			let deltaY = 0, deltaX = 0;
			if (snake == 0) { N = N - 1; }
			if (is == 0) { xs = 0; ys = 0; snakeMatrix = []; deltaY = 0; deltaX = 1; }
			else {
				let stepMatrix = [];
				let stepMatrixLabirint = [];
				let exists;
				if (ys + deltaYold < FS / 2 && xs + deltaXold < FS / 2 && ys + deltaYold > -FS / 2 && xs + deltaXold > -FS / 2
					&& ys + deltaYold + xs + deltaXold >= -FS / 2 - 1
					&& ys + deltaYold + xs + deltaXold <= FS / 2 + 1
					&& -ys - deltaYold + xs + deltaXold >= -FS / 2 - 1
					&& ys + deltaYold - xs - deltaXold >= -FS / 2 - 1
				) {
					exists = snakeMatrix.some(item => item[0] === ys + deltaYold && item[1] === xs + deltaXold);
					if (!exists) {
						//stepMatrix.push([ys + deltaYold, xs + deltaXold]);
						//stepMatrix.push([ys + deltaYold, xs + deltaXold]);
						//stepMatrix.push([ys + deltaYold, xs + deltaXold]);
						//stepMatrix.push([ys + deltaYold, xs + deltaXold]);
					}
				}
				deltaY = 1; deltaX = 0;
				if (ys + deltaY < fieldSize / 2 + 0.5
					&& xs + deltaX < fieldSize / 2
					&& ys + deltaY > -fieldSize / 2
					&& xs + deltaX > -fieldSize / 2
					&& ys + deltaY + xs + deltaX >= -fieldSize / 2 - 1
					&& ys + deltaY + xs + deltaX <= fieldSize / 2 + 1
					&& -ys - deltaY + xs + deltaX >= -fieldSize / 2 - 1
					&& ys + deltaY - xs - deltaX >= -fieldSize / 2 - 1
				) {
					exists = snakeMatrix.some(item => item[0] === ys + deltaY && item[1] === xs + deltaX);
					if (!exists) {
						//stepMatrix.push([ys + deltaY, xs + deltaX]);
						if (fieldMatrix[(ys + deltaY) * 2 + fieldSize][(xs + deltaX) * 2 + fieldSize] == 0) {
							stepMatrix.push([ys + deltaY, xs + deltaX]);
							if (fieldMatrix[(ys + deltaY) * 2 + fieldSize - deltaY][(xs + deltaX) * 2 + fieldSize - deltaX] == 2) {
								//alert(fieldMatrix[(ys + deltaY) * 2 + FS - deltaY][(xs + deltaX) * 2 + FS - deltaX]);
								stepMatrixLabirint.push([ys + deltaY, xs + deltaX]);
							}
						}
					}
				}
				deltaY = -1; deltaX = 0;
				if (ys + deltaY < fieldSize / 2 + 0.5
					&& xs + deltaX < fieldSize / 2
					&& ys + deltaY > -fieldSize / 2
					&& xs + deltaX > -fieldSize / 2
					&& ys + deltaY + xs + deltaX >= -fieldSize / 2 - 1
					&& ys + deltaY + xs + deltaX <= fieldSize / 2 + 1
					&& -ys - deltaY + xs + deltaX >= -fieldSize / 2 - 1
					&& ys + deltaY - xs - deltaX >= -fieldSize / 2 - 1
				) {
					exists = snakeMatrix.some(item => item[0] === ys + deltaY && item[1] === xs + deltaX);
					if (!exists) {
						//stepMatrix.push([ys + deltaY, xs + deltaX]);
						if (fieldMatrix[(ys + deltaY) * 2 + fieldSize][(xs + deltaX) * 2 + fieldSize] == 0) {
							stepMatrix.push([ys + deltaY, xs + deltaX]);
							if (fieldMatrix[(ys + deltaY) * 2 + fieldSize - deltaY][(xs + deltaX) * 2 + fieldSize - deltaX] == 2) {
								stepMatrixLabirint.push([ys + deltaY, xs + deltaX]);
							}
						}
					}
				}
				deltaY = 0; deltaX = 1;
				if (ys + deltaY < fieldSize / 2 + 0.5
					&& xs + deltaX < fieldSize / 2
					&& ys + deltaY > -fieldSize / 2
					&& xs + deltaX > -fieldSize / 2
					&& ys + deltaY + xs + deltaX >= -fieldSize / 2 - 1
					&& ys + deltaY + xs + deltaX <= fieldSize / 2 + 1
					&& -ys - deltaY + xs + deltaX >= -fieldSize / 2 - 1
					&& ys + deltaY - xs - deltaX >= -fieldSize / 2 - 1
				) {
					exists = snakeMatrix.some(item => item[0] === ys + deltaY && item[1] === xs + deltaX);
					if (!exists) {
						//stepMatrix.push([ys + deltaY, xs + deltaX]);
						if (fieldMatrix[(ys + deltaY) * 2 + fieldSize][(xs + deltaX) * 2 + fieldSize] == 0) {
							stepMatrix.push([ys + deltaY, xs + deltaX]);
							if (fieldMatrix[(ys + deltaY) * 2 + fieldSize - deltaY][(xs + deltaX) * 2 + fieldSize - deltaX] == 2) {
								stepMatrixLabirint.push([ys + deltaY, xs + deltaX]);
							}
						}
					}
				}
				deltaY = 0; deltaX = -1;
				if (ys + deltaY < fieldSize / 2 + 0.5
					&& xs + deltaX < fieldSize / 2
					&& ys + deltaY > -fieldSize / 2
					&& xs + deltaX > -fieldSize / 2
					&& ys + deltaY + xs + deltaX >= -fieldSize / 2 - 1
					&& ys + deltaY + xs + deltaX <= fieldSize / 2 + 1
					&& -ys - deltaY + xs + deltaX >= -fieldSize / 2 - 1
					&& ys + deltaY - xs - deltaX >= -fieldSize / 2 - 1
				) {
					exists = snakeMatrix.some(item => item[0] === ys + deltaY && item[1] === xs + deltaX);
					if (!exists) {
						//stepMatrix.push([ys + deltaY, xs + deltaX]);
						if (fieldMatrix[(ys + deltaY) * 2 + fieldSize][(xs + deltaX) * 2 + fieldSize] == 0) {
							stepMatrix.push([ys + deltaY, xs + deltaX]);
							if (fieldMatrix[(ys + deltaY) * 2 + fieldSize - deltaY][(xs + deltaX) * 2 + fieldSize - deltaX] == 2) {
								stepMatrixLabirint.push([ys + deltaY, xs + deltaX]);
							}
						}
					}
				}
				if (stepMatrixLabirint.length == 0) {
					if (stepMatrix.length == 0) {
						deltaY = 0;
						deltaX = 1;
						xs = 0;
						ys = 0;
					} else {
						const randomInt = Math.floor(Math.random() * (stepMatrix.length));
						ys = +stepMatrix[randomInt][0];
						xs = +stepMatrix[randomInt][1];
					}
				} else {
					const randomInt = Math.floor(Math.random() * (stepMatrixLabirint.length));
					ys = +stepMatrixLabirint[randomInt][0];
					xs = +stepMatrixLabirint[randomInt][1];
				}

			}
			snakeMatrix.push([ys, xs]);
			if (snakeMatrix.length > N) {
				let old = snakeMatrix[0];
				document.getElementById(cellId(pref, old[1] * 2 + FS, old[0] * 2 + FS)).bgColor = index2Color(fieldMatrix[old[0] * 2 + fieldSize][old[1] * 2 + fieldSize]);
				old = snakeMatrix[1];
				document.getElementById(cellId(pref, old[1] * 2 + FS, old[0] * 2 + FS)).bgColor = index2Color(fieldMatrix[old[0] * 2 + fieldSize][old[1] * 2 + fieldSize]);
				old = snakeMatrix[2];
				document.getElementById(cellId(pref, old[1] * 2 + FS, old[0] * 2 + FS)).bgColor = index2Color(fieldMatrix[old[0] * 2 + fieldSize][old[1] * 2 + fieldSize]);
			}
			snakeMatrix = snakeMatrix.slice(-N);
			for (let k = 0; k < snakeMatrix.length; k++) {
				let pos = snakeMatrix[k];
				document.getElementById(cellId(pref, pos[1] * 2 + FS, pos[0] * 2 + FS)).bgColor = adjustColor(index2Color(fieldMatrix[pos[0] * 2 + fieldSize][pos[1] * 2 + fieldSize]), 70 * k / snakeMatrix.length);
			}
			//document.getElementById(cellId(pref, ys * 2 + FS, xs * 2 + FS)).bgColor = adjustColor(document.getElementById(cellId(pref, ys * 2 + FS, xs * 2 + FS)).bgColor, 20);
			is++;
			await delay(120);
			if (N > 0) {
				fnSnakeII(deltaY, deltaX);
			}
		}

		// Функція для автоматичного затемнення або освітлення кольору
		function adjustColor(hex, percent = 20) {
			// Видаляємо # якщо є
			hex = hex.replace(/^#/, '');
			// Перетворюємо в числа
			let r = parseInt(hex.substring(0, 2), 16);
			let g = parseInt(hex.substring(2, 4), 16);
			let b = parseInt(hex.substring(4, 6), 16);

			// Визначаємо яскравість (перцептивна формула)
			let brightness = 0.299 * r + 0.587 * g + 0.114 * b;

			// Якщо світлий — затемнюємо, якщо темний — освітлюємо
			if (brightness > 186) {
				// Темнішаємо
				r = Math.max(0, r - Math.round(r * percent / 100));
				g = Math.max(0, g - Math.round(g * percent / 100));
				b = Math.max(0, b - Math.round(b * percent / 100));
			} else {
				// Світлішаємо
				r = Math.min(255, r + Math.round((255 - r) * percent / 100));
				g = Math.min(255, g + Math.round((255 - g) * percent / 100));
				b = Math.min(255, b + Math.round((255 - b) * percent / 100));
			}

			// Повертаємо у форматі #rrggbb
			return "#" + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
		}

		// Приклад використання:
		//let newColor = adjustColor("#aabbcc"); // автоматично зробить світліший або темніший

		function fnQuery() { robot(1); }// Call the robot function with query = 1

		function fnAuto() {
			if (gameOver == 1) { fnNewGame(); }
			roboSwitch = 0;
			document.getElementById(grayCellId).bgColor = roboSwitch == 1 ? index2Color(0) : index2Color(2);
			robot(2);
		}

		async function fnChanger(delta) {
			if (changeSize == 0) {
				fieldSize = fieldSize + delta;
				if (delta > 0 && FS < fieldSize) { FS = fieldSize; }
				saveValue("fieldSize", fieldSize);
				saveValue("FS", FS);
				writeMatrix();
				writeHtml(1);
			}
		}

		function fnLevel(delta) {
			if (gameLevel > 0 || delta > 0) {
				gameLevel = gameLevel + delta;
				document.getElementById(cellId("v", FS * 2 - 1, FS * 2 - 1)).innerText = gameLevel;
				saveValue("level", gameLevel);
			}
		}

		function fnNewGame() {
			let id = cellId("v", "01", "01");
			if (changeSize == 0) {
				gameOver = 0;
				gameColorIndex = firstColorIndex;
				document.getElementById(id).bgColor = index2Color(gameColorIndex);
				let f = 0;
				if (gameColorIndex == secondColorIndex) {
					f = 1;
				}
				document.getElementById(id).innerHTML = `<font color=${index2Color(f)}>${document.getElementById(id).innerText}</font>`;
				greenVar = 0;
				roboSwitch = 0;
				if (newLevel > 0) {
					fnChanger(2);
					fnLevel(1);
					newLevel = 0;
				} else if (newLevel < 0) {
					fnChanger(-2);
					fnLevel(-1);
					newLevel = 0;
				} else {
					writeHtml(0);
				}
			}
		}

		function createCoordX(fs) {
			let html = [];
			html.push('<TABLE border=0 cellSpacing=0 id="coordtabX">');
			html.push('<TR>');
			for (let x = 0; x < FS * 2 + 1; x++) {
				html.push(`<TD style="width:${x % 2 == 1 ? 10 * linesWidth : 0}px; font-size: ${tableWidth / (6.0 * FS)}; height: "${linesWidth}px" align="center" valign="down">`);
				if (x % 2 == 1) { html.push(`${x / 2 + 0.5}`); }
				html.push('</TD>');
			}
			html.push('</TR>');
			html.push('</TABLE>');
			return html.join('');
		}

		function createCoordY(fs) {
			let html = [];
			html.push(`<TABLE border=0 cellSpacing=0 id="coordtabY" height="${tableWidth}px">`);
			for (let x = 0; x < FS * 2 + 1; x++) {
				html.push(`<TR><TD style="height:${x % 2 == 1 ? linesWidth : 0}px; font-size: ${tableWidth / (6.0 * FS)}; width: "${linesWidth}px" align="right" valign="middle">`);
				if (x % 2 == 1) { html.push(`${x / 2 + 0.5}`); }
				html.push('</TD></TR>');
			}
			html.push('</TABLE>');
			return html.join('');
		}

	</script>

	<style>
		/* Скидання стилів для всієї сторінки */
		html,
		body {
			margin: 0;
			padding: 0;
			box-sizing: border-box;
			font-size: 16px;
			/* Базовий розмір шрифту */
			/*font-family: Arial, sans-serif;*/
			/* Ваш шрифт */
			background: #fff;
		}

		/* Скидання для заголовків */
		h1,
		h2,
		h3,
		h4,
		h5,
		h6 {
			margin: 0;
			padding: 0;
			/*font-weight: normal;*/
		}

		/* Скидання для таблиць */
		table {
			border-collapse: collapse;
			margin: 0;
			padding: 0;
		}
	</style>
	<!-- Insert HTML here -->
	<h1 style="margin-bottom: 0em"><span style="color: #0000ff;">X</span><span style="color: #ffff00;">O</span><span
			style="font-weight: normal;">Game</span><span style="font-size: 10px;">17</span></h1>
	<table border=0 cellSpacing=0 cellPadding=0>
		<tr>
			<td></td>
			<td id="column1">
				<div id="tc"></div>
			</td>
		</tr>
		<tr>
			<td valign="top">
				<div id="tv"></div>
			</td>
			<td valign="top">
				<div id="tx"></div>
			</td>
			<td rowspan="3" align="left" valign="top">
				<div id="dyL"></div>
				<table border=0 cellSpacing=0 cellPadding=1>
					<tr>
						<td valign="top" id="column3L">
							<div id="ntL"></div>
							<small>
								<div id="statL"></div>
							</small>
						</td>
						<td valign="top" width="0px">
							<div id="textingL"></div>
						</td>
					</tr>
				</table>
			</td>
		</tr>
		<tr>
			<td></td>
			<td>
				<div id="dy"></div>
			</td>
		</tr>
		<tr>
			<td colspan="3">
				<table border=0 cellSpacing=0 cellPadding=1>
					<tr>
						<td valign="top" id="column3">
							<div id="nt"></div>
							<small>
								<div id="stat"></div>
							</small>
						</td>
						<td valign="top" width="150px">
							<div id="texting"></div>
						</td>
					</tr>
				</table>
				<!--<div id="ex"></div>-->
				<!--<div id="displ"></div>-->
				<!--<div id="histo"></div>-->

			</td>
		</tr>
	</table>
	<!--<INPUT type="text" ID=redCell value="">-->
</BODY>

</HTML>